<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
    
      
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/themes/blue/pace-theme-minimal.css">























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=6.7.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.7.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.7.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.7.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.7.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.7.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: 'AQT4XGM95O',
      apiKey: 'd55e0adb332e8d9ef9023a6b4afd46f1',
      indexName: 'my',
      hits: {"per_page":10},
      labels: {"input_placeholder":"请输入搜索内容","hits_empty":"没有发现和 ${query} 有关的内容","hits_stats":"在 ${time} ms 内发现 ${hits} "}
    }
  };
</script>


  




  <meta name="description" content="javaspring分布式数据库">
<meta name="keywords" content="java,spring,分布式,数据库">
<meta property="og:type" content="website">
<meta property="og:title" content="枫秀天涯">
<meta property="og:url" content="http://fengxiutianya.top/page/4/index.html">
<meta property="og:site_name" content="枫秀天涯">
<meta property="og:description" content="javaspring分布式数据库">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="枫秀天涯">
<meta name="twitter:description" content="javaspring分布式数据库">






  <link rel="canonical" href="http://fengxiutianya.top/page/4/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>枫秀天涯</title>
  




  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-136781627-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'UA-136781627-1');
  </script>









  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">枫秀天涯</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fengxiutianya.top/posts/70e3f5d8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="枫秀天涯">
      <meta itemprop="description" content="java,spring,分布式,数据库">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="枫秀天涯">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/posts/70e3f5d8/" class="post-title-link" itemprop="url">事务隔离性实现</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-03-21 06:33:27" itemprop="dateCreated datePublished" datetime="2019-03-21T06:33:27+08:00">2019-03-21</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-08 11:14:09" itemprop="dateModified" datetime="2019-05-08T11:14:09+08:00">2019-05-08</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据库/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据库/基础/" itemprop="url" rel="index"><span itemprop="name">基础</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/posts/70e3f5d8/#comments" itemprop="discussionUrl">
                
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="posts/70e3f5d8/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/posts/70e3f5d8/" class="leancloud_visitors" data-flag-title="事务隔离性实现">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">5.9k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">5 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在多个事务并发执行时，事务的隔离性不一定能保持。为保持事务的隔离性，系统必须对并发事务之间的相互协作加以控制；这种控制是通过一种称为<strong>并发控制</strong>来实现。下面将介绍多种机制，但是没有哪种机制明显是最好的。每种机制都有优势。在实践中，最常用的是俩阶段封锁和快照隔离。本篇文章的主要内容就是分别介绍下面几种并发控制机制。</p>
<ol>
<li>基于封锁的协议</li>
<li>基于时间戳的协议</li>
<li>多版本机制</li>
</ol>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/posts/70e3f5d8/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    

    
    
    

      

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fengxiutianya.top/posts/e9892254/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="枫秀天涯">
      <meta itemprop="description" content="java,spring,分布式,数据库">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="枫秀天涯">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/posts/e9892254/" class="post-title-link" itemprop="url">事务隔离性简介</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-03-21 03:50:00" itemprop="dateCreated datePublished" datetime="2019-03-21T03:50:00+08:00">2019-03-21</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-08 11:14:09" itemprop="dateModified" datetime="2019-05-08T11:14:09+08:00">2019-05-08</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据库/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据库/基础/" itemprop="url" rel="index"><span itemprop="name">基础</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/posts/e9892254/#comments" itemprop="discussionUrl">
                
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="posts/e9892254/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/posts/e9892254/" class="leancloud_visitors" data-flag-title="事务隔离性简介">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">4.2k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">4 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文主要讲解事务四大特性ACID中的隔离性，这里简单介绍什么是隔离性，接着介绍隔离性级别以及每种隔离性会带来的相应的读的问题，最后简单介绍数据库是如何实现事务的隔离性。</p>
<ol>
<li>什么是隔离性</li>
<li>隔离性级别</li>
<li>隔离性级别的实现方式简介</li>
</ol>
<h2 id="什么是隔离性"><a href="#什么是隔离性" class="headerlink" title="什么是隔离性"></a>什么是隔离性</h2><p>在数据库系统中会存在多个事务可能并发执行，系统保证，对于任何一对事务T1和T2，在T1看来，T2或者在T1开始之前就已经完成执行，或者在T1完成之后开始执行。因此，每个事务都感觉不到系统中有其他事务在并发的执行。这就是事务的隔离性<br>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/posts/e9892254/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </p></div>

    

    
    
    

      

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fengxiutianya.top/posts/2313243/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="枫秀天涯">
      <meta itemprop="description" content="java,spring,分布式,数据库">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="枫秀天涯">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/posts/2313243/" class="post-title-link" itemprop="url">java线程系列 JUC同步器 10 Semaphore</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-03-20 14:51:38" itemprop="dateCreated datePublished" datetime="2019-03-20T14:51:38+08:00">2019-03-20</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-08 11:14:09" itemprop="dateModified" datetime="2019-05-08T11:14:09+08:00">2019-05-08</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/juc/" itemprop="url" rel="index"><span itemprop="name">juc</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/juc/tools/" itemprop="url" rel="index"><span itemprop="name">tools</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/posts/2313243/#comments" itemprop="discussionUrl">
                
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="posts/2313243/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/posts/2313243/" class="leancloud_visitors" data-flag-title="java线程系列 JUC同步器 10 Semaphore">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">9.1k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">8 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>从字面意思理解就是信号量，本质上来说是用于线程之间访问共享资源，是一种同步原语，只是访问的资源可能有多个，其实现是通过AQS框架。在我们开发中，经常会碰见使用信号量的场景，比如出于系统性能的考虑需要限流，这时需要控制同时访问共享资源的最大线程数量，或者共享资源是稀缺资源，我们需要有一种办法能够协调各个线程，以保证合理的使用公共资源。<br>可以看下图来理解<br><img src="/images/pasted-309.png" alt="upload successful"><br>有四个线程来共同竞争资源，现在信号量是5，则表明共享资源的数量是5。如果每个线程申请一个资源，则可以同时满足5个线程申请资源，每个线程在使用完之后，需要释放资源。如果在线程在申请资源的时候，没有足够的资源来满足，则会阻塞线程。<br>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/posts/2313243/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </p></div>

    

    
    
    

      

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fengxiutianya.top/posts/c05d7ca/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="枫秀天涯">
      <meta itemprop="description" content="java,spring,分布式,数据库">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="枫秀天涯">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/posts/c05d7ca/" class="post-title-link" itemprop="url">java线程系列 JUC同步器09 CyclicBarrier</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-03-19 11:32:00" itemprop="dateCreated datePublished" datetime="2019-03-19T11:32:00+08:00">2019-03-19</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-08 11:14:09" itemprop="dateModified" datetime="2019-05-08T11:14:09+08:00">2019-05-08</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/juc/" itemprop="url" rel="index"><span itemprop="name">juc</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/juc/tools/" itemprop="url" rel="index"><span itemprop="name">tools</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/posts/c05d7ca/#comments" itemprop="discussionUrl">
                
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="posts/c05d7ca/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/posts/c05d7ca/" class="leancloud_visitors" data-flag-title="java线程系列 JUC同步器09 CyclicBarrier">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">12k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">11 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>字面意思回环栅栏，通过它可以实现让一组线程等待至某个状态之后再全部同时执行。叫做回环是因为当所有等待线程都被释放以后，CyclicBarrier可以被重用。我们暂且把这个状态就叫做barrier，当调用await()方法之后，线程就处于barrier了。</p>
<p>可以看下面这个图来理解下:<br>一共4个线程A、B、C、D，它们到达栅栏的顺序可能各不相同。当A、B、C到达栅栏后，由于没有满足总数4的要求，所以会一直等待，当线程D到达后，栅栏才会放行。</p>
<p><img src="/images/pasted-306.png" alt="upload successful"><br>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/posts/c05d7ca/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </p></div>

    

    
    
    

      

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fengxiutianya.top/posts/b071530c/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="枫秀天涯">
      <meta itemprop="description" content="java,spring,分布式,数据库">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="枫秀天涯">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/posts/b071530c/" class="post-title-link" itemprop="url">java线程系列 JUC同步器 08 CountDownLatch</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-03-19 10:34:00" itemprop="dateCreated datePublished" datetime="2019-03-19T10:34:00+08:00">2019-03-19</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-08 11:14:09" itemprop="dateModified" datetime="2019-05-08T11:14:09+08:00">2019-05-08</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/juc/" itemprop="url" rel="index"><span itemprop="name">juc</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/juc/tools/" itemprop="url" rel="index"><span itemprop="name">tools</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/posts/b071530c/#comments" itemprop="discussionUrl">
                
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="posts/b071530c/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/posts/b071530c/" class="leancloud_visitors" data-flag-title="java线程系列 JUC同步器 08 CountDownLatch">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">11k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">10 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>正如每个Java文档所描述的那样，<a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CountDownLatch.html" target="_blank" rel="noopener">CountDownLatch</a>是一个同步工具类，它允许一个或多个线程一直等待，直到其他线程的操作执行完后再执行。在Java并发中，countdownlatch的概念是一个常见的面试题，所以一定要确保你很好的理解了它。</p>
<h2 id="CountDownLatch是什么"><a href="#CountDownLatch是什么" class="headerlink" title="CountDownLatch是什么"></a>CountDownLatch是什么</h2><p>CountDownLatch是在java1.5被引入的，跟它一起被引入的并发工具类还有CyclicBarrier和Semaphore，它们都存在于java.util.concurrent包下，后面会讲解另外俩个。CountDownLatch这个类能够使一个线程等待其他线程完成各自的工作后再执行。例如，应用程序的主线程希望在负责启动框架服务的线程已经启动所有的框架服务之后再执行。</p>
<p>CountDownLatch是通过一个计数器来实现的，计数器的初始值为线程的数量。每当一个线程完成了自己的任务后，计数器的值就会减1。当计数器值到达0时，它表示所有的线程已经完成了任务，然后在闭锁上等待的线程就可以恢复执行任务。</p>
<p><img src="/images/pasted-302.png" alt="upload successful"></p>
<p>如上图：TA主线程会一直等待，等待T1、T2和T3将计数器减为0，才继续执行。</p>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/posts/b071530c/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    

    
    
    

      

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fengxiutianya.top/posts/18178dca/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="枫秀天涯">
      <meta itemprop="description" content="java,spring,分布式,数据库">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="枫秀天涯">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/posts/18178dca/" class="post-title-link" itemprop="url">java线程系列 JUC锁 07 ReentrantReadWriteLock</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-03-19 03:46:00" itemprop="dateCreated datePublished" datetime="2019-03-19T03:46:00+08:00">2019-03-19</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-08 11:14:09" itemprop="dateModified" datetime="2019-05-08T11:14:09+08:00">2019-05-08</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/juc/" itemprop="url" rel="index"><span itemprop="name">juc</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/juc/lock/" itemprop="url" rel="index"><span itemprop="name">lock</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/posts/18178dca/#comments" itemprop="discussionUrl">
                
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="posts/18178dca/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/posts/18178dca/" class="leancloud_visitors" data-flag-title="java线程系列 JUC锁 07 ReentrantReadWriteLock">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">17k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">16 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="ReentrantReadWriteLock-简介"><a href="#ReentrantReadWriteLock-简介" class="headerlink" title="ReentrantReadWriteLock 简介"></a>ReentrantReadWriteLock 简介</h2><p>在前面我们已经分析过JUC中的独占锁：ReentrantLock。本篇文章将对JUC的读写锁ReentrantReadWriteLock进行介绍。</p>
<p>类如如下：</p>
<p><img src="/images/pasted-300.png" alt="upload successful"></p>
<p>从上图可以看出ReentrantReadWriteLock实现了ReadWriteLock接口，而这个接口从名字就可以看出是读写锁。它维护了一对相关连的锁：读锁和写锁。作用如下</p>
<ul>
<li>读锁：用于只读操作，不会修改共享数据。是共享锁，能够同时被多个线程锁获取。</li>
<li>写锁：用于写入操作，是独占锁，只能被一个线程锁获取。</li>
</ul>
<p>而这个接口提供了俩个抽象函数，获取读锁的readLock()函数和获取写锁的writeLock()函数。</p>
<p>ReentrantReadWriteLock中包含：Sync对象，读锁ReadLock和写锁WriteLock。</p>
<p>读锁ReadLock和写锁WriteLock都实现了Lock接口。读锁ReadLock和写锁WriteLock中也都分别包含了相同的Sync对象，里面所有的功能实现也都是靠这个对象。它们的Sync对象和ReentrantReadWriteLock的Sync对象是一样，就是通过sync，读锁和写锁实现了对同一个对象的访问。</p>
<p>和ReentrantLock一样，Sync也是一个继承于AQS的抽象类。Sync也包括公平锁FairSync和非公平锁NonfairSync。在创建读写锁时可以选择其中俩个其中一个，默认是NonfairSync。<br>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/posts/18178dca/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </p></div>

    

    
    
    

      

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fengxiutianya.top/posts/ad8369f2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="枫秀天涯">
      <meta itemprop="description" content="java,spring,分布式,数据库">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="枫秀天涯">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/posts/ad8369f2/" class="post-title-link" itemprop="url">java线程系列 JUC锁 06 阻塞原语LockSupport</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-03-18 12:56:00" itemprop="dateCreated datePublished" datetime="2019-03-18T12:56:00+08:00">2019-03-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-08 11:14:09" itemprop="dateModified" datetime="2019-05-08T11:14:09+08:00">2019-05-08</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/juc/" itemprop="url" rel="index"><span itemprop="name">juc</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/juc/lock/" itemprop="url" rel="index"><span itemprop="name">lock</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/posts/ad8369f2/#comments" itemprop="discussionUrl">
                
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="posts/ad8369f2/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/posts/ad8369f2/" class="leancloud_visitors" data-flag-title="java线程系列 JUC锁 06 阻塞原语LockSupport">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">11k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">10 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol>
<li>用法简介</li>
<li>源码分析</li>
<li>底层实现原理</li>
</ol>
<h3 id="1-用法简介"><a href="#1-用法简介" class="headerlink" title="1. 用法简介"></a>1. 用法简介</h3><p>LockSupport是用来创建锁和其他同步器的基本<strong>线程阻塞</strong>原语。LockSupport 提供park()和unpark()方法实现阻塞线程和解除线程阻塞。每个使用LockSupport的线程都与一个许可(permit)关联，permit相当于开关，默认是0，调用一次unpark就加1变成1，调用一次park会消费permit, 也就是将1变成0，同时park立即返回。再次调用park会变成block（因为permit为0，会阻塞在这里，直到permit变为1）, 这时调用unpark会把permit置为1。每个线程都有一个相关的permit, permit最多只有一个，重复调用unpark也不会积累。</p>
<p>park()和unpark()不会有Thread.suspend和Thread.resume所可能引发的死锁问题。这个死锁问题的产生是由于Thread.resume在Thread.suspend之前调用，使得线程忽略了解除阻塞的信号，而使得线程一直被阻塞。而LockSupport由于许可的存在，调用park的线程和另一个试图将其unpark的线程之间的竞争将保持活性。不会因为前后调用的顺序而产生死锁</p>
<p>如果调用线程被中断，则park方法会返回。同时park也拥有可以设置超时时间的版本。<br>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/posts/ad8369f2/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </p></div>

    

    
    
    

      

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fengxiutianya.top/posts/e7f5c004/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="枫秀天涯">
      <meta itemprop="description" content="java,spring,分布式,数据库">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="枫秀天涯">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/posts/e7f5c004/" class="post-title-link" itemprop="url">AbstractQueuedSynchronizer</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-03-18 12:00:00" itemprop="dateCreated datePublished" datetime="2019-03-18T12:00:00+08:00">2019-03-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-08 11:14:09" itemprop="dateModified" datetime="2019-05-08T11:14:09+08:00">2019-05-08</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/juc/" itemprop="url" rel="index"><span itemprop="name">juc</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/juc/lock/" itemprop="url" rel="index"><span itemprop="name">lock</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/posts/e7f5c004/#comments" itemprop="discussionUrl">
                
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="posts/e7f5c004/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/posts/e7f5c004/" class="leancloud_visitors" data-flag-title="AbstractQueuedSynchronizer">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">17k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">15 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>在J2SE 1.5的java.util.concurrent包（下称j.u.c包）中，大部分的同步器（例如锁，屏障等等）都是基于AbstractQueuedSynchronizer（下称AQS类）这个简单的框架来构建的。这个框架为同步状态的原子性管理、线程的阻塞和解除阻塞以及排队提供了一种通用机制。这篇论文主要描述了这个框架基本原理、设计、实现、用法以及性能。</p>
<h3 id="1-背景介绍"><a href="#1-背景介绍" class="headerlink" title="1. 背景介绍"></a>1. 背景介绍</h3><p>通过JCP的JSR166规范，Java的1.5版本引入了j.u.c包，这个包提供了一系列支持中等程度并发的类。这些组件是一系列的同步器（抽象数据类型(ADT)）。这些同步器主要维护着以下几个功能：内部同步状态的管理(例如：表示一个锁的状态是获取还是释放)，同步状态的更新和检查操作，且至少有一个方法会导致调用线程在同步状态被获取时阻塞，以及在其他线程改变这个同步状态时解除线程的阻塞。上述的这些的实际例子包括：互斥排它锁的不同形式、读写锁、信号量、屏障、Future、事件指示器以及传送队列等。</p>
<p>几乎任一同步器都可以用来实现其他形式的同步器。例如，可以用可重入锁实现信号量或者用信号量实现可重入锁。但是，这样做带来的复杂性，开销，不灵活使其至多只能是个二流工程。且缺乏吸引力。如果任何这样的构造方式不能在本质上比其他形式更简洁，那么开发者就不应该随意地选择其中的某个来构建另一个同步器。取而代之，JSR166建立了一个小框架，AQS类。这个框架为构造同步器提供一种通用的机制，并且被j.u.c包中大部分类使用，同时很多用户也用它来定义自己的同步器。</p>
<p>在这篇论文的下面部分会讨论这个框架的需求、设计与实现背后的主要思路、示例用法，以及性能指标的一些测量。</p>
<h3 id="2-需求"><a href="#2-需求" class="headerlink" title="2 需求"></a>2 需求</h3><h4 id="2-1-功能"><a href="#2-1-功能" class="headerlink" title="2.1 功能"></a>2.1 功能</h4><p>同步器一般包含两种方法，一种是acquire，另一种是release。acquire操作阻塞调用的线程，直到或除非同步状态允许其继续执行。而release操作则是通过某种方式改变同步状态，使得一或多个被acquire阻塞的线程继续执行。</p>
<p>j.u.c包中并没有对同步器的API做一个统一的定义。因此，有一些类定义了通用的接口（如Lock），而另外一些则定义了其专有的版本。因此在不同的类中，acquire和release操作的名字和形式会各有不同。例如：Lock.lock，Semaphore.acquire，CountDownLatch.await和FutureTask.get，在这个框架里，这些方法都是acquire操作。但是，J.U.C为支持一系列常见的使用选项，在类间都有个一致约定。在有意义的情况下，每一个同步器都支持下面的操作：</p>
<ul>
<li>阻塞和非阻塞（例如tryLock）同步。</li>
<li>可选的超时设置，让调用者可以放弃等待</li>
<li>通过中断实现的任务取消，通常是分为两个版本，一个acquire可取消，而另一个不可以。</li>
</ul>
<p>同步器的实现根据其状态是否独占而有所不同。独占状态的同步器，在同一时间只有一个线程可以通过阻塞点，而共享状态的同步器可以同时有多个线程在执行。一般锁的实现类往往只维护独占状态，但是，例如计数信号量在数量许可的情况下，允许多个线程同时执行。为了使框架能得到广泛应用，这两种模式都要支持。</p>
<p>j.u.c包里还定义了Condition接口，用于支持管程形式的await/signal操作，这些操作与独占模式的Lock类有关，且Condition的实现天生就和与其关联的Lock类紧密相关。</p>
<h4 id="2-2-性能目标"><a href="#2-2-性能目标" class="headerlink" title="2.2 性能目标"></a>2.2 性能目标</h4><p>Java内置锁（使用synchronized的方法或代码块）的性能问题一直以来都在被人们关注，并且已经有一系列的文章描述其构造（例如引文[1],[3]）。然而，大部分的研究主要关注的是在单核处理器上大部分时候使用于单线程上下文环境中时，如何尽量降低其空间（因为任何的Java对象都可以当成是锁）和时间的开销。对于同步器来说这些都不是特别重要：程序员仅在需要的时候才会使用同步器，因此并不需要压缩空间来避免浪费，并且同步器几乎是专门用在多线程设计中（特别是在多核处理器上），在这种环境下，偶尔的竞争是在意料之中的。因此，常规的JVM锁优化策略主要是针对零竞争的场景，而其它场景则使用缺乏可预见性的“慢速路径（slow paths）” ，所以常规的JVM锁优化策略并不适用于严重依赖于J.U.C包的典型多线程服务端应用。</p>
<p>这里主要的性能目标是可伸缩性，即在大部分情况下，即使，或特别在同步器有竞争的情况下，稳定地保证其效率。在理想的情况下，不管有多少线程正试图通过同步点，通过同步点的开销都应该是个常量。在某一线程被允许通过同步点但还没有通过的情况下，使其耗费的总时间最少，这是主要目标之一。然而，这也必须考虑平衡各种资源，包括总CPU时间的需求，内存负载以及线程调度的开销。例如：获取自旋锁通常比阻塞锁所需的时间更短，但是通常也会浪费CPU时钟周期，并且造成内存竞争，所以使用的并不频繁。</p>
<p>实现同步器的这些目标包含了两种不同的使用类型。大部分应用程序是最大化其总的吞吐量，容错性，并且最好保证尽量减少饥饿的情况。然而，对于那些控制资源分配的程序来说，更重要是去维持多线程读取的公平性，可以接受较差的总吞吐量。没有任何框架可以代表用户去决定应该选择哪一个方式，因此，应该提供不同的公平策略。</p>
<p>无论同步器的内部实现是多么的精雕细琢，它还是会在某些应用中产生性能瓶颈。因此，框架必须提供相应的监视工具让用户发现和缓和这些瓶颈。至少需要提供一种方式来确定有多少线程被阻塞了。</p>
<h3 id="3-设计与实现"><a href="#3-设计与实现" class="headerlink" title="3 设计与实现"></a>3 设计与实现</h3><p>同步器背后的基本思想非常简单。acquire操作如下：</p>
<pre><code>while (synchronization state does not allow acquire) {
    enqueue current thread if not already queued;
    possibly block current thread;
}
dequeue current thread if it was queued;
</code></pre><p>release操作如下：</p>
<pre><code>update synchronization state;
if (state may permit a blocked thread to acquire)
    unblock one or more queued threads;

</code></pre><p>为了实现上述操作，需要下面三个基本组件的相互协作：</p>
<ul>
<li>同步状态的原子性管理；</li>
<li>线程的阻塞与解除阻塞；</li>
<li>队列的管理；</li>
</ul>
<p>创建一个框架分别实现这三个组件是有可能的。但是，这会让整个框架既难用又没效率。例如：存储在队列节点的信息必须与解除阻塞所需要的信息一致，而暴露出的方法的签名必须依赖于同步状态的特性。</p>
<p>同步器框架的核心决策是为这三个组件选择一个具体实现，同时在使用方式上又有大量选项可用。这里有意地限制了其适用范围，但是提供了足够的效率，使得实际上没有理由在合适的情况下不用这个框架而去重新建造一个。</p>
<h4 id="3-1-同步状态"><a href="#3-1-同步状态" class="headerlink" title="3.1 同步状态"></a>3.1 同步状态</h4><p>AQS类使用单个<code>int</code>（32位）来保存同步状态，并暴露出<code>getState</code>、<code>setState</code>以及<code>compareAndSet</code>操作来读取和更新这个状态。这些方法都依赖于j.u.c.atomic包的支持，这个包提供了兼容JSR133中<code>volatile</code>在读和写上的语义，并且通过使用本地的compare-and-swap或load-linked/store-conditional指令来实现<code>compareAndSetState</code>，使得仅当同步状态拥有一个期望值的时候，才会被原子地设置成新值。</p>
<p>将同步状态限制为一个32位的整形是出于实践上的考量。虽然JSR166也提供了64位<code>long</code>字段的原子性操作，但这些操作在很多平台上还是使用内部锁的方式来模拟实现的，这会使同步器的性能可能不会很理想。当然，将来可能会有一个类是专门使用64位的状态的。然而现在就引入这么一个类到这个包里并不是一个很好的决定（<em>译者注：JDK1.6中已经包含java.util.concurrent.locks.AbstractQueuedLongSynchronizer类，即使用 long 形式维护同步状态的一个 AbstractQueuedSynchronizer 版本</em>）。目前来说，32位的状态对大多数应用程序都是足够的。在j.u.c包中，只有一个同步器类可能需要多于32位来维持状态，那就是<code>CyclicBarrier</code>类，所以，它用了锁（该包中大多数更高层次的工具亦是如此）。</p>
<p>基于AQS的具体实现类必须根据暴露出的状态相关的方法定义<code>tryAcquire</code>和<code>tryRelease</code>方法，以控制acquire和release操作。当同步状态满足时，<code>tryAcquire</code>方法必须返回<code>true</code>，而当新的同步状态允许后续acquire时，<code>tryRelease</code>方法也必须返回<code>true</code>。这些方法都接受一个<code>int</code>类型的参数用于传递想要的状态。例如：可重入锁中，当某个线程从条件等待中返回，然后重新获取锁时，为了重新建立循环计数的场景。很多同步器并不需要这样一个参数，因此忽略它即可。</p>
<h4 id="3-2-阻塞"><a href="#3-2-阻塞" class="headerlink" title="3.2 阻塞"></a>3.2 阻塞</h4><p>在JSR166之前，阻塞线程和解除线程阻塞都是基于Java内置管程，没有其它非基于Java内置管程的API可以用来创建同步器。唯一可以选择的是<code>Thread.suspend</code>和<code>Thread.resume</code>，但是它们都有无法解决的竞态问题，所以也没法用：当一个非阻塞的线程在一个正准备阻塞的线程调用<code>suspend</code>前调用了<code>resume</code>，这个<code>resume</code>操作将不会有什么效果。</p>
<p>j.u.c包有一个<code>LockSuport</code>类，这个类中包含了解决这个问题的方法。方法<code>LockSupport.park</code>阻塞当前线程除非/直到有个<code>LockSupport.unpark</code>方法被调用（<code>unpark</code>方法被提前调用也是可以的）。<code>unpark</code>的调用是没有被计数的，因此在一个<code>park</code>调用前多次调用<code>unpark</code>方法只会解除一个<code>park</code>操作。另外，它们作用于每个线程而不是每个同步器。一个线程在一个新的同步器上调用park操作可能会立即返回，因为在此之前可能有“剩余的”<code>unpark</code>操作。但是，在缺少一个<code>unpark</code>操作时，下一次调用park就会阻塞。虽然可以显式地消除这个状态（<em>译者注：就是多余的unpark调用</em>），但并不值得这样做。在需要的时候多次调用<code>park</code>会更高效。</p>
<p>这个简单的机制与有些用法在某种程度上是相似的，例如Solaris-9的线程库，WIN32中的“可消费事件”，以及Linux中的NPTL线程库。因此最常见的运行Java的平台上都有相对应的有效实现。（但目前Solaris和Linux上的Sun Hotspot JVM参考实现实际上是使用一个pthread的condvar来适应目前的运行时设计的）。<code>park</code>方法同样支持可选的相对或绝对的超时设置，以及与JVM的<code>Thread.interrupt</code>结合 —— 可通过中断来<code>unpark</code>一个线程。</p>
<h4 id="3-3-队列"><a href="#3-3-队列" class="headerlink" title="3.3 队列"></a>3.3 队列</h4><p>整个框架的关键就是如何管理被阻塞的线程的队列，该队列是严格的FIFO队列，因此，框架不支持基于优先级的同步。</p>
<p>同步队列的最佳选择是自身没有使用底层锁来构造的非阻塞数据结构，目前，业界对此很少有争议。而其中主要有两个选择：一个是Mellor-Crummey和Scott锁（MCS锁）<a href="http://ifeve.com/aqs-2/#r9" target="_blank" rel="noopener">[9]</a>的变体，另一个是Craig，Landin和Hagersten锁（CLH锁）<a href="http://ifeve.com/aqs-2/#r5" target="_blank" rel="noopener">[5]</a><a href="http://ifeve.com/aqs-2/#r8" target="_blank" rel="noopener">[8]</a><a href="http://ifeve.com/aqs-2/#r10" target="_blank" rel="noopener">[10]</a>的变体。一直以来，CLH锁仅被用于自旋锁。但是，在这个框架中，CLH锁显然比MCS锁更合适。因为CLH锁可以更容易地去实现“取消（cancellation）”和“超时”功能，因此我们选择了CLH锁作为实现的基础。但是最终的设计已经与原来的CLH锁有较大的出入，因此下文将对此做出解释。</p>
<p>CLH队列实际上并不那么像队列，因为它的入队和出队操作都与它的用途（即用作锁）紧密相关。它是一个链表队列，通过两个字段<code>head</code>和<code>tail</code>来存取，这两个字段是可原子更新的，两者在初始化时都指向了一个空节点。</p>
<p><img src="http://ifeve.com/wp-content/uploads/2013/01/CLHNode.png" alt="CLH队列节点间的关系"></p>
<p>一个新的节点，node，通过一个原子操作入队：</p>
<pre><code>do {
    pred = tail;
} while(!tail.compareAndSet(pred, node));

</code></pre><p>每一个节点的“释放”状态都保存在其前驱节点中。因此，自旋锁的“自旋”操作就如下：</p>
<pre><code>while (pred.status != RELEASED); // spin
</code></pre><p>自旋后的出队操作只需将head字段指向刚刚得到锁的节点：</p>
<pre><code>head = node;
</code></pre><p>CLH锁的优点在于其入队和出队操作是快速、无锁的，以及无障碍的（即使在竞争下，某个线程总会赢得一次插入机会而能继续执行）；且探测是否有线程正在等待也很快（只要测试一下head是否与tail相等）；同时，“释放”状态是分散的（<em>译者注：几乎每个节点都保存了这个状态，当前节点保存了其后驱节点的“释放”状态，因此它们是分散的，不是集中于一块的。</em>），避免了一些不必要的内存竞争。</p>
<p>在原始版本的CLH锁中，节点间甚至都没有互相链接。自旋锁中，<code>pred</code>变量可以是一个局部变量。然而，Scott和Scherer证明了通过在节点中显式地维护前驱节点，CLH锁就可以处理“超时”和各种形式的“取消”：如果一个节点的前驱节点取消了，这个节点就可以滑动去使用前面一个节点的状态字段。</p>
<p>为了将CLH队列用于阻塞式同步器，需要做些额外的修改以提供一种高效的方式定位某个节点的后继节点。在自旋锁中，一个节点只需要改变其状态，下一次自旋中其后继节点就能注意到这个改变，所以节点间的链接并不是必须的。但在阻塞式同步器中，一个节点需要显式地唤醒（<code>unpark</code>）其后继节点。</p>
<p>AQS队列的节点包含一个<code>next</code>链接到它的后继节点。但是，由于没有针对双向链表节点的类似<code>compareAndSet</code>的原子性无锁插入指令，因此这个<code>next</code>链接的设置并非作为原子性插入操作的一部分，而仅是在节点被插入后简单地赋值：</p>
<pre><code>pred.next = node;
</code></pre><p><code>next</code>链接仅是一种优化。如果通过某个节点的<code>next</code>字段发现其后继结点不存在（或看似被取消了），总是可以使用<code>pred</code>字段从尾部开始向前遍历来检查是否真的有后续节点。</p>
<p>第二个对CLH队列主要的修改是将每个节点都有的状态字段用于控制阻塞而非自旋。在同步器框架中，仅在线程调用具体子类中的<code>tryAcquire</code>方法返回<code>true</code>时，队列中的线程才能从<code>acquire</code>操作中返回；而单个“released”位是不够的。但仍然需要做些控制以确保当一个活动的线程位于队列头部时，仅允许其调用<code>tryAcquire</code>；这时的<code>acquire</code>可能会失败，然后（重新）阻塞。这种情况不需要读取状态标识，因为可以通过检查当前节点的前驱是否为<code>head</code>来确定权限。与自旋锁不同，读取<code>head</code>以保证复制时不会有太多的内存竞争（ there is not enough memory contention reading head to warrant replication.）。然而，“取消”状态必须存在于状态字段中。</p>
<p>队列节点的状态字段也用于避免没有必要的<code>park</code>和<code>unpark</code>调用。虽然这些方法跟阻塞原语一样快，但在跨越Java和JVM runtime以及操作系统边界时仍有可避免的开销。在调用<code>park</code>前，线程设置一个“唤醒（signal me）”位，然后再一次检查同步和节点状态。一个释放的线程会清空其自身状态。这样线程就不必频繁地尝试阻塞，特别是在锁相关的类中，这样会浪费时间等待下一个符合条件的线程去申请锁，从而加剧其它竞争的影响。除非后继节点设置了“唤醒”位（<em>译者注：源码中为-1</em>），否则这也可避免正在release的线程去判断其后继节点。这反过来也消除了这些情形：除非“唤醒”与“取消”同时发生，否则必须遍历多个节点来处理一个似乎为null的<code>next</code>字段。</p>
<p>同步框架中使用的CLH锁的变体与其他语言中的相比，主要区别可能是同步框架中使用的CLH锁需要依赖垃圾回收管理节点的内存，这就避免了一些复杂性和开销。但是，即使依赖GC也仍然需要在确定链接字段不再需要时将其置为null。这往往可以与出队操作一起完成。否则，无用的节点仍然可触及，它们就没法被回收。</p>
<p>其它一些更深入的微调，包括CLH队列首次遇到竞争时才需要的初始空节点的延迟初始化等，都可以在J2SE1.5的版本的源代码文档中找到相应的描述。</p>
<p>抛开这些细节，基本的<code>acquire</code>操作的最终实现的一般形式如下（互斥，非中断，无超时）：</p>
<pre><code>if(!tryAcquire(arg)) {
    node = create and enqueue new node;
    pred = node&#39;s effective predecessor;
    while (pred is not head node || !tryAcquire(arg)) {
        if (pred&#39;s signal bit is set)
            pard()
        else
            compareAndSet pred&#39;s signal bit to true;
        pred = node&#39;s effective predecessor;
    }
    head = node;
}
</code></pre><p><code>release</code>操作：</p>
<pre><code>if(tryRelease(arg) &amp;&amp; head node&#39;s signal bit is set) {
    compareAndSet head&#39;s bit to false;
    unpark head&#39;s successor, if one exist
}
</code></pre><p><code>acquire</code>操作的主循环次数依赖于具体实现类中<code>tryAcquire</code>的实现方式。另一方面，在没有“取消”操作的情况下，每一个组件的<code>acquire</code>和<code>release</code>都是一个O(1)的操作，忽略<code>park</code>中发生的所有操作系统线程调度。</p>
<p>支持“取消”操作主要是要在<code>acquire</code>循环里的<code>park</code>返回时检查中断或超时。由超时或中断而被取消等待的线程会设置其节点状态，然后<code>unpark</code>其后继节点。在有“取消”的情况下，判断其前驱节点和后继节点以及重置状态可能需要O(n)的遍历（n是队列的长度）。由于“取消”操作，该线程再也不会被阻塞，节点的链接和状态字段可以被快速重建。</p>
<h4 id="3-4-条件队列"><a href="#3-4-条件队列" class="headerlink" title="3.4 条件队列"></a>3.4 条件队列</h4><p>AQS框架提供了一个<code>ConditionObject</code>类，给维护独占同步的类以及实现<code>Lock</code>接口的类使用。一个锁对象可以关联任意数目的条件对象，可以提供典型的管程风格的<code>await</code>、<code>signal</code>和<code>signalAll</code>操作，包括带有超时的，以及一些检测、监控的方法。</p>
<p>通过修正一些设计决策，<code>ConditionObject</code>类有效地将条件（conditions）与其它同步操作结合到了一起。该类只支持Java风格的管程访问规则，这些规则中，仅当当前线程持有锁且要操作的条件（condition）属于该锁时，条件操作才是合法的（一些替代操作的讨论参考<a href="http://ifeve.com/aqs-2/#r4" target="_blank" rel="noopener">[4]</a>）。这样，一个<code>ConditionObject</code>关联到一个<code>ReentrantLock</code>上就表现的跟内置的管程（通过<code>Object.wait</code>等）一样了。两者的不同仅仅在于方法的名称、额外的功能以及用户可以为每个锁声明多个条件。</p>
<p><code>ConditionObject</code>使用了与同步器一样的内部队列节点。但是，是在一个单独的条件队列中维护这些节点的。<code>signal</code>操作是通过将节点从条件队列转移到锁队列中来实现的，而没有必要在需要唤醒的线程重新获取到锁之前将其唤醒。</p>
<p>基本的<code>await</code>操作如下：</p>
<pre><code>create and add new node to conditon queue;
release lock;
block until node is on lock queue;
re-acquire lock;
</code></pre><p><code>signal</code>操作如下：</p>
<pre><code>    transfer the first node from condition queue to lock queue;
</code></pre><p>因为只有在持有锁的时候才能执行这些操作，因此他们可以使用顺序链表队列操作来维护条件队列（在节点中用一个<code>nextWaiter</code>字段）。转移操作仅仅把第一个节点从条件队列中的链接解除，然后通过CLH插入操作将其插入到锁队列上。</p>
<p>实现这些操作主要复杂在，因超时或<code>Thread.interrupt</code>导致取消了条件等待时，该如何处理。“取消”和“唤醒”几乎同时发生就会有竞态问题，最终的结果遵照内置管程相关的规范。JSR133修订以后，就要求如果中断发生在<code>signal</code>操作之前，await方法必须在重新获取到锁后，抛出<code>InterruptedException</code>。但是，如果中断发生在<code>signal</code>后，<code>await</code>必须返回且不抛异常，同时设置线程的中断状态。</p>
<p>为了维护适当的顺序，队列节点状态变量中的一个位记录了该节点是否已经（或正在）被转移。“唤醒”和“取消”相关的代码都会尝试用<code>compareAndSet</code>修改这个状态。如果某次<code>signal</code>操作修改失败，就会转移队列中的下一个节点（如果存在的话）。如果某次“取消”操作修改失败，就必须中止此次转移，然后等待重新获得锁。后面的情况采用了一个潜在的无限的自旋等待。在节点成功的被插到锁队列之前，被“取消”的等待不能重新获得锁，所以必须自旋等待CLH队列插入（即<code>compareAndSet</code>操作）被“唤醒”线程成功执行。这里极少需要自旋，且自旋里使用<code>Thread.yield</code>来提示应该调度某一其它线程，理想情况下就是执行signal的那个线程。虽然有可能在这里为“取消”实现一个帮助策略以帮助插入节点，但这种情况实在太少，找不到合适的理由来增加这些开销。在其它所有的情况下，这个基本的机制都不需要自旋或<code>yield</code>，因此在单处理器上保持着合理的性能。</p>
<h3 id="4-用法"><a href="#4-用法" class="headerlink" title="4 用法"></a>4 用法</h3><p>AQS类将上述的功能结合到一起，并且作为一种基于“模版方法模式”<a href="http://ifeve.com/aqs-3/#r6" target="_blank" rel="noopener">[6]</a>的基类提供给同步器。子类只需定义状态的检查与更新相关的方法，这些方法控制着acquire和 release操作。然而，将AQS的子类作为同步器ADT并不适合，因为这个类必须提供方法在内部控制acquire和release的规则，这些都不应该被用户所看到。所有java.util.concurrent包中的同步器类都声明了一个私有的继承了<code>AbstractQueuedSynchronizer</code>的内部类，并且把所有同步方法都委托给这个内部类。这样各个同步器类的公开方法就可以使用适合自己的名称。</p>
<p>下面是一个最简单的<code>Mutex</code>类的实现，它使用同步状态0表示解锁，1表示锁定。这个类并不需要同步方法中的参数，因此这里在调用的时候使用0作为实参，方法实现里将其忽略。</p>
<pre><code>class Mutex {
    class Sync extends AbstractQueuedSynchronizer {
        public boolean tryAcquire(int ignore) {
            return compareAndSetState(0, 1);
        }
        public boolean tryRelease(int ignore) {
            setState(0); return true;
        }
    }

    private final Sync sync = new Sync();
    public void lock() { sync.acquire(0); }
    public void unlock() { sync.release(0); }
}
</code></pre><p>这个例子的一个更完整的版本，以及其它用法指南，可以在J2SE的文档中找到。还可以有一些变体。如，tryAcquire可以使用一种“test-and-test-and-set”策略，即在改变状态值前先对状态进行校验。</p>
<p>令人诧异的是，像互斥锁这样性能敏感的东西也打算通过委托和虚方法结合的方式来定义。然而，这正是现代动态编译器一直在重点研究的面向对象设计结构。编译器擅长将这方面的开销优化掉，起码会优化频繁调用同步器的那些代码。</p>
<p><code>AbstractQueuedSynchronizer</code>类也提供了一些方法用来协助策略控制。例如，基础的acquire方法有可超时和可中断的版本。虽然到目前为止，我们的讨论都集中在像锁这样的独占模式的同步器上，但<code>AbstractQueuedSynchronizer</code>类也包含另一组方法（如<code>acquireShared</code>），它们的不同点在于<code>tryAcquireShared</code>和<code>tryReleaseShared</code>方法能够告知框架（通过它们的返回值）尚能接受更多的请求，最终框架会通过级联的signal(cascading signals)唤醒多个线程。</p>
<p>虽然将同步器序列化（持久化存储或传输）一般来说没有太大意义，但这些类经常会被用于构造其它类，例如线程安全的集合，而这些集合通常是可序列化的。<code>AbstractQueuedSynchronizer</code>和<code>ConditionObject</code>类都提供了方法用于序列化同步状态，但不会序列化潜在的被阻塞的线程，也不会序列化其它内部暂时性的簿记（bookkeeping）变量。即使如此，在反序列化时，大部分同步器类也只仅将同步状态重置为初始值，这与内置锁的隐式策略一致 —— 总是反序列化到一个解锁状态。这相当于一个空操作，但仍必须显式地支持以便<code>final</code>字段能够反序列化。</p>
<h4 id="4-1-公平调度的控制"><a href="#4-1-公平调度的控制" class="headerlink" title="4.1 公平调度的控制"></a>4.1 公平调度的控制</h4><p>尽管同步器是基于FIFO队列的，但它们并不一定就得是公平的。可以注意到，在基础的acquire算法（3.3节）中，<code>tryAcquire</code>是在入队前被执行的。因此一个新的acquire线程能够“窃取”本该属于队列头部第一个线程通过同步器的机会。</p>
<p>可<em>闯入</em>的FIFO策略通常会提供比其它技术更高的总吞吐率。当一个有竞争的锁已经空闲，而下一个准备获取锁的线程又正在解除阻塞的过程中，这时就没有线程可以获取到这个锁，如果使用<em>闯入</em>策略，则可减少这之间的时间间隔。与此同时，这种策略还可避免过分的，无效率的竞争，这种竞争是由于只允许一个（第一个）排队的线程被唤醒然后尝试acquire操作导致的。在只要求短时间持有同步器的场景中，创建同步器的开发者可以通过定义<code>tryAcquire</code>在控制权返回之前重复调用自己若干次，来进一步凸显<em>闯入</em>的效果。</p>
<p><a href="http://ifeve.com/wp-content/uploads/2013/01/fifo.png" target="_blank" rel="noopener"><img src="http://ifeve.com/wp-content/uploads/2013/01/fifo-300x90.png" alt="img"></a></p>
<p>可闯入的FIFO同步器只有概率性的公平属性。锁队列头部一个解除了阻塞的线程拥有一次无偏向的机会（<em>译者注：即不会偏向队头的线程也不会偏向闯入的线程</em>）来赢得与<em>闯入</em>的线程之间的竞争，如果竞争失败，要么重新阻塞要么进行重试。然而，如果<em>闯入</em>的线程到达的速度比队头的线程解除阻塞快，那么在队列中的第一个线程将很难赢得竞争，以至于几乎总要重新阻塞，并且它的后继节点也会一直保持阻塞。对于短暂持有的同步器来说，在队列中第一个线程被解除阻塞期间，多处理器上很可能发生过多次<em>闯入</em>（<em>译者注：即闯入的线程的acquire操作</em>）和<code>release</code>了。正如下文所提到的，最终结果就是保持一或多个线程的高进展速度的同时，仍至少在一定概率上避免了饥饿的发生。</p>
<p>当有更高的公平性需求时，实现起来也很简单。如果需要严格的公平性，程序员可以把tryAcquire方法定义为，若当前线程不是队列的头节点（可通过<code>getFirstQueuedThread</code>方法检查，这是框架提供的为数不多的几个检测方法之一），则立即失败（返回false）。</p>
<p>一个更快，但非严格公平的变体可以这样做，若队列为空（判断的瞬间），仍然允许<code>tryAcquire</code>执行成功。在这种情况下，多个线程同时遇到一个空队列时可能会去竞争以使自己第一个获得锁，这样，通常至少有一个线程是无需入队列的。<code>java.util.concurrent</code>包中所有支持公平模式的同步器都采用了这种策略。</p>
<p>尽管公平性设置在实践中很有用，但是它们并没有保障，因为Java Language Specification没有提供这样的调度保证。例如：即使是严格公平的同步器，如果一组线程永远不需要阻塞来达到互相等待，那么JVM可能会决定纯粹以顺序方式运行它们。在实际中，单处理器上，在抢占式上下文切换之前，这样的线程有可能是各自运行了一段时间。如果这样一个线程正持有某个互斥锁，它将很快会被切换回来，仅是为了释放其持有的锁，然后会继续阻塞，因为它知道有另外一个线程需要这把锁，这更增加了同步器可用但没有线程能来获取之间的间隔。同步器公平性设置在多处理器上的影响可能会更大，因为在这种环境下会产生更多的交错，因此一个线程就会有更多的机会发现锁被另一个线程请求。</p>
<p>在高竞争下，当保护的是短暂持有锁的代码体时，尽管性能可能会较差，但公平锁仍然能有效地工作。例如，当公平性锁保护的是相对长的代码体和/或有着相对长的锁间(inter-lock)间隔，在这种情况下，<em>闯入</em>只能带来很小的性能优势，但却可能会大大增加无限等待的风险。同步器框架将这些工程决策留给用户来确定。</p>
<h4 id="4-2-同步器"><a href="#4-2-同步器" class="headerlink" title="4.2 同步器"></a>4.2 同步器</h4><p>下面是<code>java.util.concurrent</code>包中同步器定义方式的概述：</p>
<p><code>ReentrantLock</code>类使用AQS同步状态来保存锁（重复）持有的次数。当锁被一个线程获取时，<code>ReentrantLock</code>也会记录下当前获得锁的线程标识，以便检查是否是重复获取，以及当错误的线程（<em>译者注：如果线程不是锁的持有者，在此线程中执行该锁的unlock操作就是非法的</em>）试图进行解锁操作时检测是否存在非法状态异常。<code>ReentrantLock</code>也使用了AQS提供的ConditionObject，还向外暴露了其它监控和监测相关的方法。<code>ReentrantLock</code>通过在内部声明两个不同的<code>AbstractQueuedSynchronizer</code>实现类（提供公平模式的那个禁用了<em>闯入</em>策略）来实现可选的公平模式，在创建ReentrantLock实例的时候根据设置（<em>译者注：即ReentrantLock构造方法中的fair参数</em>）使用相应的<code>AbstractQueuedSynchronizer</code>实现类。</p>
<p><code>ReentrantReadWriteLock</code>类使用AQS同步状态中的16位来保存写锁持有的次数，剩下的16位用来保存读锁的持有次数。<code>WriteLock</code>的构建方式同<code>ReentrantLock</code>。<code>ReadLock</code>则通过使用<code>acquireShared</code>方法来支持同时允许多个读线程。</p>
<p><code>Semaphore</code>类（计数信号量）使用AQS同步状态来保存信号量的当前计数。它里面定义的acquireShared方法会减少计数，或当计数为非正值时阻塞线程；<code>tryRelease</code>方法会增加计数，可能在计数为正值时还要解除线程的阻塞。</p>
<p><code>CountDownLatch</code>类使用AQS同步状态来表示计数。当该计数为0时，所有的acquire操作（<em>译者注：acquire操作是从aqs的角度说的，对应到CountDownLatch中就是await方法</em>）才能通过。</p>
<p><code>FutureTask</code>类使用AQS同步状态来表示某个异步计算任务的运行状态（初始化、运行中、被取消和完成）。设置（<em>译者注：FutureTask的set方法</em>）或取消（<em>译者注：FutureTask的cancel方法</em>）一个<code>FutureTask</code>时会调用AQS的<code>release</code>操作，等待计算结果的线程的阻塞解除是通过AQS的<code>acquire</code>操作实现的。</p>
<p><code>SynchronousQueues</code>类（一种CSP<em>（Communicating Sequential Processes）</em>形式的传递）使用了内部的等待节点，这些节点可以用于协调生产者和消费者。同时，它使用AQS同步状态来控制当某个消费者消费当前一项时，允许一个生产者继续生产，反之亦然。</p>
<p><code>java.util.concurrent</code>包的使用者当然也可以为自定义的应用定义自己的同步器。例如，那些曾考虑到过的，但没有采纳进这个包的同步器包括提供WIN32事件各种风格的语义类，二元信号量，集中管理的锁以及基于树的屏障。</p>
<h2 id="5-性能"><a href="#5-性能" class="headerlink" title="5 性能"></a>5 性能</h2><p>虽然AQS框架除了支持互斥锁外，还支持其它形式的同步方式，但锁的性能是最容易测量和比较的。即使如此，也还存在许多不同的测量方式。这里的实验主要是设计来展示锁的开销和吞吐量。</p>
<p>在每个测试中，所有线程都重复的更新一个伪随机数，该随机数由<code>nextRandom(int seed)</code>方法计算：</p>
<pre><code>int t = (seed % 127773) * 16807 - (seed / 127773) * 2836;
return (t &gt; 0) ? t : t + 0x7fffffff;
</code></pre><p>在每次迭代中，线程以概率S在一个互斥锁下更新共享的生成器，否则（<em>译者注：概率为1-S</em>）更新其自己局部的生成器，此时是不需要锁的。如此，锁占用区域的耗时是短暂的，这就使线程持有锁期间被抢占时的外界干扰降到了最小。这个函数的随机性主要是为了两个目的：确定是否需要使用锁（这个生成器足以应付这里的需求），以及使循环中的代码不可能被轻易地优化掉。</p>
<p>这里比较了四种锁：内置锁，用的是<code>synchronized</code>块；互斥锁，用的是像第四节例子中的那样简单的Mutex类；可重入锁，用的是<code>ReentrantLock</code>；以及公平锁，用的是<code>ReentrantLock</code>的公平模式。所有测试都运行在J2SE1.5 JDK build46（大致与beta2相同）的server模式下。在收集测试数据前，测试程序先运行20次非竞争的测试，以排除JVM“预热”（<em>译者注：更多关于“预热”的内容，参见：Java 理论与实践: 动态编译与性能测量</em>）过程的影响。除了公平模式下的测试只跑了一百万次迭代，其它每个线程中的测试都运行了一千万次迭代。</p>
<p>该测试运行在四个X86机器和四个UltraSparc机器上。所有X86机器都运行的是RedHat基于NPTL 2.4内核和库的Linux系统。所有的UltraSparc机器都运行的是Solaris-9。测试时所有系统的负载都很轻。根据该测试的特征，并不要求系统完全空闲（<em>译者注：即测试时操作系统上有其它较轻的负载也不会影响本次测试的结果。</em>）。“4P”这个名字反映出双核超线程的Xeon更像是4路机器，而不是2路机器。这里没有将测试数据规范化。如下所示，同步的相对开销与处理器的数量、类型、速度之间不具备简单的关系。</p>
<p><strong>表1 测试的平台</strong></p>
<table>
<thead>
<tr>
<th>名字</th>
<th>处理器数量</th>
<th>类型</th>
<th>速度(Mhz)</th>
</tr>
</thead>
<tbody>
<tr>
<td>1P</td>
<td>1</td>
<td>Pentium3</td>
<td>900</td>
</tr>
<tr>
<td>2P</td>
<td>2</td>
<td>Pentium3</td>
<td>1400</td>
</tr>
<tr>
<td>2A</td>
<td>2</td>
<td>Athlon</td>
<td>2000</td>
</tr>
<tr>
<td>4P</td>
<td>2HT</td>
<td>Pentium4/Xeon</td>
<td>2400</td>
</tr>
<tr>
<td>1U</td>
<td>1</td>
<td>UltraSparc2</td>
<td>650</td>
</tr>
<tr>
<td>4U</td>
<td>4</td>
<td>UltraSparc2</td>
<td>450</td>
</tr>
<tr>
<td>8U</td>
<td>8</td>
<td>UltraSparc3</td>
<td>750</td>
</tr>
<tr>
<td>24U</td>
<td>24</td>
<td>UltraSparc3</td>
<td>750</td>
</tr>
</tbody>
</table>
<h3 id="5-1-开销"><a href="#5-1-开销" class="headerlink" title="5.1 开销"></a>5.1 开销</h3><p>无竞争情况下的开销是通过仅运行一个线程，将概率S为1时的每次迭代时间减去概率S为0（访问共享内存的概率为0）时的每次迭代时间得到的（<em>译者注：这里的“概率S”即前文提到的“概率S”，概率为0时是没有锁操作的，概率为1时是每次都有锁操作，因此将概率为1时的耗时减去概率为0时的耗时就是整个锁操作的开销。</em>）。表2以纳秒为单位显示了非竞争场景下每次锁操作的开销。Mutex类最接近于框架的基本耗时，可重入锁的额外开销是记录当前所有者线程和错误检查的耗时，对于公平锁来说还包含开始时检查队列是否为空的耗时。</p>
<p>表格2也展示与内置锁的“快速路径（fast path）”对比，<code>tryAcquire</code>的耗时。这里的差异主要反映出了各锁和机器中使用的不同的原子指令以及内存屏障的耗时。在多处理器上，这些指令常常是完全优于所有其它指令的。内置锁和同步器类之间的主要差别，显然是由于Hotspot锁在锁定和解锁时都使用了一次<code>compareAndSet</code>，而同步器的<code>acquire</code>操作使用了一次<code>compareAndSet</code>，但<code>release</code>操作用的是一次<code>volatile</code>写（即，多处理器上的一次内存屏障以及所有处理器上的重排序限制）。每个锁的绝对的和相对耗时因机器的不同而不同。</p>
<p><strong>表2 无竞争时的单锁开销（单位：纳秒）</strong></p>
<table>
<thead>
<tr>
<th>机器</th>
<th>内置</th>
<th>互斥</th>
<th>可重入</th>
<th>公平可重入</th>
</tr>
</thead>
<tbody>
<tr>
<td>1P</td>
<td>18</td>
<td>9</td>
<td>31</td>
<td>37</td>
</tr>
<tr>
<td>2P</td>
<td>58</td>
<td>71</td>
<td>77</td>
<td>81</td>
</tr>
<tr>
<td>2A</td>
<td>13</td>
<td>21</td>
<td>31</td>
<td>30</td>
</tr>
<tr>
<td>4P</td>
<td>116</td>
<td>95</td>
<td>109</td>
<td>117</td>
</tr>
<tr>
<td>1U</td>
<td>90</td>
<td>40</td>
<td>58</td>
<td>67</td>
</tr>
<tr>
<td>4U</td>
<td>122</td>
<td>82</td>
<td>100</td>
<td>115</td>
</tr>
<tr>
<td>8U</td>
<td>160</td>
<td>83</td>
<td>103</td>
<td>123</td>
</tr>
<tr>
<td>24U</td>
<td>161</td>
<td>84</td>
<td>108</td>
<td>119</td>
</tr>
</tbody>
</table>
<p>从另一个极端看，表3展示了概率S为1，运行256个并发线程时产生了大规模的锁竞争下每个锁的开销。在完全饱和的情况下，可<em>闯入</em>的FIFO锁比内置锁的开销少了一个数量级（也就是更大的吞吐量），比公平锁更是少了两个数量级。这表现出即使有着极大的竞争，在维持线程进展方面可<em>闯入</em>FIFO策略的效率。</p>
<p>表3也说明了即使在内部开销比较低的情况下，公平锁的性能也完全是由上下文切换的时间所决定的。列出的时间大致上都与各平台上线程阻塞和解除线程阻塞的时间相称。</p>
<p>此外，后面增加的一个实验（仅使用机器4P）表明，对于这里用到的短暂持有的锁，公平参数的设置在总差异中的影响很小。这里将线程终止时间间的差异记录成一个粗粒度的离散量数。在4P的机器上，公平锁的时间度量的标准差平均为0.7%，可重入锁平均为6.0%。作为对比，为模拟一个长时间持有锁的场景，测试中使每个线程在持有锁的情况下计算了16K次随机数。这时，总运行时间几乎是相同的（公平锁：9.79s，可重入锁：9.72s）。公平模式下的差异依然很小，标准差平均为0.1%，而可重入锁上升到了平均29.5%。</p>
<p><strong>表格3 饱和时的单锁开销（单位：纳秒）</strong></p>
<table>
<thead>
<tr>
<th>机器</th>
<th>内置</th>
<th>互斥</th>
<th>可重入</th>
<th>公平可重入</th>
</tr>
</thead>
<tbody>
<tr>
<td>1P</td>
<td>521</td>
<td>46</td>
<td>67</td>
<td>8327</td>
</tr>
<tr>
<td>2P</td>
<td>930</td>
<td>108</td>
<td>132</td>
<td>14967</td>
</tr>
<tr>
<td>2A</td>
<td>748</td>
<td>79</td>
<td>84</td>
<td>33910</td>
</tr>
<tr>
<td>4P</td>
<td>1146</td>
<td>188</td>
<td>247</td>
<td>15328</td>
</tr>
<tr>
<td>1U</td>
<td>879</td>
<td>153</td>
<td>177</td>
<td>41394</td>
</tr>
<tr>
<td>4U</td>
<td>2590</td>
<td>347</td>
<td>368</td>
<td>30004</td>
</tr>
<tr>
<td>8U</td>
<td>1274</td>
<td>157</td>
<td>174</td>
<td>31084</td>
</tr>
<tr>
<td>24U</td>
<td>1983</td>
<td>160</td>
<td>182</td>
<td>32291</td>
</tr>
</tbody>
</table>
<h3 id="5-2-吞吐量"><a href="#5-2-吞吐量" class="headerlink" title="5.2 吞吐量"></a>5.2 吞吐量</h3><p>大部分同步器都是用于无竞争和极大竞争之间的。这可以用实验在两个方面进行检查，通过修改固定个线程的竞争概率，和/或通过往拥有固定竞争概率的线程集合里增加更多的线程。为了说明这些影响，测试运行在不同的竞争概率和不同的线程数目下，都用的是可重入锁。附图使用了一个<em>slowdown</em>度量标准。</p>
<p><a href="http://ifeve.com/wp-content/uploads/2013/02/formula.jpg" target="_blank" rel="noopener"><img src="http://ifeve.com/wp-content/uploads/2013/02/formula-300x66.jpg" alt="img"></a></p>
<p>这里，t是总运行时间，b是一个线程在没有竞争或同步下的基线时间，n是线程数，p是处理器数，S是共享访问的比例（<em>译者注：即前面的竞争概率S</em>）。计算结果是实际执行时间与理想执行时间（通常是无法得到的）的比率，理想执行时间是通过使用Amdahl’s法则计算出来的。理想时间模拟了一次没有同步开销，没有因锁争用而导致线程阻塞的执行过程。即使这样，在很低的竞争下，相比理想时间，有一些测试结果却表现出了很小的速度增长，大概是由于基线和测试之间的优化、流水线等方面有着轻微的差别。</p>
<p>图中用以2为底的对数为比例进行了缩放。例如，值为1表示实际时间是理想时间的两倍，4表示慢16倍。使用对数就不需要依赖一个随意的基线时间（这里指的是计算随机数的时间），因此，基于不同底数计算的结果表现出的趋势应该是类似的。这些测试使用的竞争概率从1/128（标识为“0.008”）到1，以2的幂为步长，线程的数量从1到1024，以2的幂的一半为步长。</p>
<p>在单处理器（1P和1U）上，性能随着竞争的上升而下降，但不会随着线程数的增加而下降。多处理器在遭遇竞争时，性能下降的更快。根据多处理器相关的图表显示，开始出现的峰值处虽然只有几个线程的竞争，但相对性能通常却最差。这反映出了一个性能的<em>过渡区域</em>，在这里<em>闯入</em>的线程和被唤醒的线程都准备获取锁，这会让它们频繁的迫使对方阻塞。在大部分时候，过渡区域后面会紧接着一个<em>平滑区域</em>，因为此时几乎没有空闲的锁，所以会与单处理器上顺序执行的模式差不多；在多处理器机器上会较早进入平滑区域。例如，请注意，在满竞争（标识为“1.000”）下这些值表示，在处理器越少的机器上，会有更糟糕的相对速度下降。</p>
<p>根据这些结果，可以针对阻塞（park/unpark）做进一步调优以减少上下文切换和相关的开销，这会给本框架带来小但显著的提升。此外，在多处理器上为短时间持有的但高竞争的锁采用某种形式的适应性自旋，可以避免这里看到的一些波动，这对同步器类大有裨益。虽然在跨不同上下文时适应性自旋很难很好的工作，但可以使用本框架为遇到这类使用配置的特定应用构建一个自定义形式的锁。</p>
<p><a href="http://ifeve.com/wp-content/uploads/2013/02/1.jpg" target="_blank" rel="noopener"><img src="http://ifeve.com/wp-content/uploads/2013/02/1-1024x409.jpg" alt="img"></a><br><a href="http://ifeve.com/wp-content/uploads/2013/02/2.jpg" target="_blank" rel="noopener"><img src="http://ifeve.com/wp-content/uploads/2013/02/2-1024x385.jpg" alt="img"></a><br><a href="http://ifeve.com/wp-content/uploads/2013/02/3.jpg" target="_blank" rel="noopener"><img src="http://ifeve.com/wp-content/uploads/2013/02/3-1024x409.jpg" alt="img"></a><br><a href="http://ifeve.com/wp-content/uploads/2013/02/4.jpg" target="_blank" rel="noopener"><img src="http://ifeve.com/wp-content/uploads/2013/02/4-1024x409.jpg" alt="img"></a></p>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h2><p>本文撰写之时，<code>java.util.concurrent</code>包中的同步器框架还太新所以还不能在实践中使用。因此在J2SE 1.5最终版本发布之前都很难看到其大范围的使用，并且，它的设计，API实现以及性能肯定还有无法预料的后果。但是，此时，这个框架明显能胜任其基本的目标，即为创建新的同步器提供一个高效的基础。</p>

          
        
      
    </div>

    

    
    
    

      

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fengxiutianya.top/posts/d14480c0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="枫秀天涯">
      <meta itemprop="description" content="java,spring,分布式,数据库">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="枫秀天涯">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/posts/d14480c0/" class="post-title-link" itemprop="url">java线程系列 JUC锁 05  Condition条件</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-03-18 11:56:00" itemprop="dateCreated datePublished" datetime="2019-03-18T11:56:00+08:00">2019-03-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-08 11:14:09" itemprop="dateModified" datetime="2019-05-08T11:14:09+08:00">2019-05-08</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/juc/" itemprop="url" rel="index"><span itemprop="name">juc</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/juc/lock/" itemprop="url" rel="index"><span itemprop="name">lock</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/posts/d14480c0/#comments" itemprop="discussionUrl">
                
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="posts/d14480c0/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/posts/d14480c0/" class="leancloud_visitors" data-flag-title="java线程系列 JUC锁 05  Condition条件">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">17k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">15 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>Condition的作用是对锁进行更精确的控制。Condition中的await()方法相当于Object的wait方法，Condition中的signal()方法相当于Object的notify()方法，Condition中的signalAll()相当于Object的notifyAll()方法。不同的是，Object中的wait()、notify()、notifyAll()方法是和同步锁(synchronized关键字)捆绑使用的；而Condition是需要与斥锁/共享锁捆绑使用的。互斥锁前面已经说过一个ReentrantLock，后还会说道ReentrantReadWriteLock共享锁。<br>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/posts/d14480c0/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </p></div>

    

    
    
    

      

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fengxiutianya.top/posts/3a5a614f/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="枫秀天涯">
      <meta itemprop="description" content="java,spring,分布式,数据库">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="枫秀天涯">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/posts/3a5a614f/" class="post-title-link" itemprop="url">Atomic</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-03-18 08:37:00" itemprop="dateCreated datePublished" datetime="2019-03-18T08:37:00+08:00">2019-03-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-08 11:14:09" itemprop="dateModified" datetime="2019-05-08T11:14:09+08:00">2019-05-08</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/juc/" itemprop="url" rel="index"><span itemprop="name">juc</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/juc/atomic/" itemprop="url" rel="index"><span itemprop="name">atomic</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/posts/3a5a614f/#comments" itemprop="discussionUrl">
                
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="posts/3a5a614f/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/posts/3a5a614f/" class="leancloud_visitors" data-flag-title="Atomic">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">18k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">16 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Atomic"><a href="#Atomic" class="headerlink" title="Atomic"></a>Atomic</h1><h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><blockquote>
<ol>
<li>Atomic包介绍</li>
<li>CAS 介绍</li>
<li>基本类型解析以及使用</li>
<li>引用类型解析以及使用</li>
<li>数组类型解析以及使用</li>
<li>属性原子修改器(Updater)解析以及使用</li>
<li>Java 8新增加的LongAdder等类的解析以及使用</li>
</ol>
</blockquote>
<h3 id="Atomic包介绍"><a href="#Atomic包介绍" class="headerlink" title="Atomic包介绍"></a>Atomic包介绍</h3><blockquote>
<p>这个包主要是一个小型工具包，支持<strong>单个变量</strong>上的无锁线程安全编程。</p>
<p>主要的类如下图</p>
<p><img src="/images/pasted-298.png" alt="upload successful"></p>
<p>其中other这一类是java 8中新增加的类，后面会介绍。</p>
<p>虽然这包下面类很多，但是你只需要看懂其中一个，其余的方法和使用都是大同小异。</p>
</blockquote>
<h3 id="CAS-介绍"><a href="#CAS-介绍" class="headerlink" title="CAS 介绍"></a>CAS 介绍</h3><blockquote>
<p>在讲解Atomic包下面具体类的使用，我们先了解一下什么是CAS，全称Compare-and-Swap，是指比较和交换，一种特殊的处理器指令。</p>
<ul>
<li>CAS是乐观锁思想的一种实现，是为了保证一组比较替换操作原子性；当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败， 失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。</li>
<li>CAS乐观锁的实现与悲观锁的区别在于当资源不用的时候悲观锁会将线程挂起而CAS会继续重试直到资源可用；</li>
</ul>
<p>乐观锁的核心算法是CAS（Compareand Swap，比较并交换），它涉及到三个操作数：内存值、预期值、新值。当且仅当预期值和内存值相等时才将内存值修改为新值。这样处理的逻辑是，首先检查某块内存的值是否跟之前我读取时的一样，如不一样则表示期间此内存值已经被别的线程更改过，舍弃本次操作，否则说明期间没有其他线程对此内存值操作，可以把新值设置给此块内存。</p>
<p>假如你足够细心你可能会发现一个疑问，比较和交换，从字面上就有两个操作了，更别说实际CAS可能会有更多的执行指令，他们是原子性的吗？如果非原子性又怎么保证CAS操作期间出现并发带来的问题？我是不是需要用上节提到的互斥锁来保证他的原子性操作？<strong>CAS肯定是具有原子性的</strong>，不然就谈不上在并发中使用了，<strong>但这个原子性是由CPU硬件指令实现保证的</strong>，即使用JNI调用native方法调用由C++编写的硬件级别指令，jdk中提供了Unsafe类执行这些操作。另外，你可能想着CAS是通过互斥锁来实现原子性的，这样确实能实现，但用这种方式来保证原子性显示毫无意义。</p>
<p>其实Atomic包下面绝大部分的实现都是通过Unsafe这个类来实现的。全名为：sun.misc.Unsafe，这个类包含了大量的对C代码的操作，包括很多直接内存分配以及原子操作的调用，而它之所以标记为非安全的，是告诉你这个里面大量的方法调用都会存在安全隐患，需要小心使用，否则会导致严重的后果，例如在通过unsafe分配内存的时候，如果自己指定某些区域可能会导致一些类似C++一样的指针越界到其他进程的问题，不过它的具体使用并不是本文的重点，</p>
<p>本文重点是Atomic系列的内容大多会基于unsafe类中的以下几个本地方法来操作：</p>
<pre><code class="Java">public final native boolean 
 compareAndSwapObject(Object paramObject1, long paramLong, 
                        Object paramObject2, Object paramObject3); 

public final native boolean 
       compareAndSwapInt(Object paramObject,long paramLong,
                            int paramInt1, int paramInt2); 

public final native boolean 
           compareAndSwapLong(Object paramObject, long paramLong1, 
                                 long paramLong2, long paramLong3);  
</code></pre>
<p>首先拿<strong>compareAndSwapObject</strong>这个函数来讲解一下大概的意思：</p>
<p><strong>对象的引用进行对比后交换，交换成功返回true，交换失败返回false</strong>，这个交换过程完全是原子的，在CPU上计算完结果后，都会对比内存的结果是否还是原先的值，若不是，则认为不能替换，因为变量是volatile类型所以最终写入的数据会被其他线程看到，所以一个线程修改成功后，其他线程就发现自己修改失败了。</p>
<p><strong>参数1：</strong>对象所在的类本身的对象（一般这里是对一个对象的属性做修改，才会出现并发，所以该对象所存在的类也是有一个对象的）</p>
<p><strong>参数2：</strong>这个属性在这个对象里面的相对便宜量位置，其实对比时是对比内存单元，所以需要属性的起始位置，而引用就是修改引用地址（根据OS、VM位数和参数配置决定宽度一般是4-8个字节），int就是修改相关的4个字节，而long就是修改相关的8个字节。</p>
<p>获取偏移量也是通过unsafe的一个方法：objectFieldOffset(Fieldfield)来获取属性在对象中的偏移量；静态变量需要通过：staticFieldOffset(Field field)获取，调用的总方法是：fieldOffset(Fieldfield)</p>
<p><strong>参数3：</strong>修改的引用的原始值，用于对比原来的引用和要修改的目标是否一致。</p>
<p><strong>参数4：</strong>修改的目标值，要将数据修改成什么。</p>
<p>其中要注意的是<strong>对long的操作，要看VM是否支持对Long的CAS，因为有可能VM本身不支持，若不支持，此时运算会变成Lock方式，不过现在VM都基本是支持的而已。</strong></p>
<h4 id="CAS存在的问题-ABA"><a href="#CAS存在的问题-ABA" class="headerlink" title="CAS存在的问题(ABA)"></a>CAS存在的问题(ABA)</h4><ul>
<li>CAS操作是进行比较替换，容易出现ABA问题；如果一个变量的初始值是A，一个线程准备将A改为了B，在这期间又有其他线程将A改回了B，又将B改回A，这个时候CAS会认为中间没有发生变化，实际上是已经是不同的这就出现了ABA问题；ABA问题的解决办法：JDK引入了解决ABA问题的Automic原子类AutomicStampedReference，使用时间戳版本号来进行标记；下面会介绍</li>
<li>在高并发的情况下会出现CAS频繁碰撞，碰撞会造成赋值失败继续重试，越多线程重试，CAS失败几率又越高，变成恶性循环，造成效率底下等问题；</li>
</ul>
</blockquote>
<h3 id="基本类型解析以及使用"><a href="#基本类型解析以及使用" class="headerlink" title="基本类型解析以及使用"></a>基本类型解析以及使用</h3><blockquote>
<p>基本类型主要有以下三种类型：AtomicInteger、AtomicLong、AtomicBoolean；用法大体上差不多，因此这里就拿AtomicInteger类来讲解。</p>
<p>我们直接来上代码，然后在解释</p>
<pre><code class="java">import java.util.concurrent.CountDownLatch;
import java.util.concurrent.atomic.AtomicInteger;

public class AtomicIntegerTest {

public final static AtomicInteger TEST_INTEGER = new AtomicInteger(1);

public static int test = 1;

public static void main(String[] args) throws InterruptedException {
  AtomicTest();
  intTest();
  CountDownLatch cd = new CountDownLatch(1);


}

/**
 * 最终打印的结果一定是：11
 *
 * @throws InterruptedException
*/
public static void AtomicTest() throws InterruptedException {
  Thread[] threads = new Thread[10];
  CountDownLatch cd = new CountDownLatch(10);
  for (int i = 0; i &lt; 10; i++) {

      final int num = i;

      threads[i] = new Thread() {
          public void run() {
              cd.countDown();
              try {

                  cd.await();  //等待10 个线程创建成功

              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
              try {
                  Thread.sleep(1000);
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }

              int now = TEST_INTEGER.incrementAndGet();

          }
      };
      threads[i].start();
  }
  for (Thread t : threads) {
      t.join();
  }
  System.out.println(&quot;AtomicTest最终运行结果：&quot; + TEST_INTEGER.get());
}

/**
   * 普通int测试。最终打印的结果不确定
*
   * @throws InterruptedException
*/
public static void intTest() throws InterruptedException {
  Thread[] threads = new Thread[10];
  CountDownLatch cd = new CountDownLatch(10);
  for (int i = 0; i &lt; 10; i++) {

      final int num = i;

      threads[i] = new Thread() {
          public void run() {
              cd.countDown();
              try {

                  cd.await();  //等待10 个线程创建成功

              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
              try {
                  Thread.sleep(1000);
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
              int now = ++test;
          }
      };

      threads[i].start();
  }
  for (Thread t : threads) {
      t.join();
  }

  System.out.println(&quot;intTest最终运行结果：&quot; + test);
}
}
</code></pre>
<p>上面的例子模拟多个线程并发对<strong>AtomicInteger</strong>和<strong>普通变量</strong>进行增加的操作，对AtomicInteger对象进行增加操作，最后得到的结果一定是11，但是对普通变量int类型的修改，得到的值不确定，可以为8，也可以为9，结果不确定。这个说明AtomicInteger是线程安全的，而普通的变量不是线程安全的。</p>
<p>AtomicInteger的主要方法如下，使用和上面使用<strong>incrementAndGet</strong>方法差不多</p>
<pre><code class="java">//构造函数
AtomicInteger()  //初始值为0
AtomicInteger(int initivalValue)  //初始值为initivalValue

int addAndGet(int delta) // 当前值加上delta,然后返回最总结果
int    getAndAdd(int delta) // 返回当前值，然后加上delta

//下面俩个方法其实是一样的效果，就是当前值为expect就设置当前值为value
boolean compareAndSet(int expect,int value)
boolean    weakCompareAndSet(int expect, int update)

int    decrementAndGet() //相当于 --i
int    incrementAndGet() //相当于 ++i
int    getAndDecrement() //相当于 i--
int    getAndIncrement() //相当于 i++

//设置当前值为newValue
void    set(int newValue)
int        getAndSet(int newValue)  //得到当前值，并设置当前值为newVlaue
void    lazySet(int newValue) //最终设置当前值为newValue，

//下面几个方法都是返回当前值
double    doubleValue()
float    floatValue()
long    longValue()
int    intValue()
int    get()


//java 8新增加的方法，其中Function都要求无副作用的函数，
int    updateAndGet(IntUnaryOperator updateFunction)
int    getAndUpdate(IntUnaryOperator updateFunction)
int    getAndAccumulate(int x, IntBinaryOperator accumulatorFunction)
int    accumulateAndGet(int x, IntBinaryOperator accumulatorFunction)
</code></pre>
<p>下面讲解一下上面比较容易弄混的函数</p>
<h4 id="compareAndSet-和weakCompareAndSet-对比"><a href="#compareAndSet-和weakCompareAndSet-对比" class="headerlink" title="compareAndSet 和weakCompareAndSet 对比"></a>compareAndSet 和weakCompareAndSet 对比</h4><blockquote>
<p>主要的区别可以看看<a href="http://www.importnew.com/27596.html" target="_blank" rel="noopener">对 volatile、compareAndSet、weakCompareAndSet 的一些思考</a></p>
</blockquote>
<h4 id="lazySet"><a href="#lazySet" class="headerlink" title="lazySet"></a>lazySet</h4><blockquote>
<p>为一个AtomicLong对象设置一个值，jvm会确保其他线程读取到最新值，原子类和voliatile变量也是一样的，这是由依赖于硬件的系统指令(如x86的xchg)实现的。lazySet却是无法保证这一点的方法，所以其他线程在之后的一小段时间里还是可以读到旧的值。</p>
<p><strong>这有什么好处呢？</strong></p>
<p><strong>性能</strong>：在多核处理器下，内存以及cpu缓存的读和写常常是顺序执行的，所以在多个cpu缓存之间同步一个内存值的代价是很昂贵的。</p>
</blockquote>
<p>另外俩个基本类型的原子类和AtomicInteger差不多，唯一的区别可能就是类型的不同。所以这里就不具体讲解。</p>
</blockquote>
<h3 id="引用类型解析以及使用"><a href="#引用类型解析以及使用" class="headerlink" title="引用类型解析以及使用"></a>引用类型解析以及使用</h3><blockquote>
<p>引用类型主要包含以下几种：AtomicReference、AtomicStampedRerence、AtomicMarkableReference；</p>
<p>首先讲解：AtomicReference</p>
<p>直接上代码演示操作</p>
<pre><code class="Java">import java.util.concurrent.atomic.AtomicReference;  

public class AtomicReferenceTest {  

public final static AtomicReference&lt;String&gt; ATOMIC_REFERENCE =
          new AtomicReference&lt;String&gt;(&quot;abc&quot;);  

public static void main(String []args) {  
  for(int i = 0 ; i &lt; 100 ; i++) {  
      final int num = i;  
      new Thread() {  
          public void run() {  
              try {  
                  Thread.sleep(Math.abs((int)(Math.random() * 100)));  
              } catch (InterruptedException e) {  
                  e.printStackTrace();  
              }  

              if(ATOMIC_REFERENCE.compareAndSet(&quot;abc&quot;, new String(&quot;abc&quot;))) {  
                  System.out.println(&quot;我是线程：&quot; + num + 
                                     &quot;,获得了锁进行了对象修改！&quot;);  
              }  
          }  
      }.start();  
  }  
}  
}  
//这个结果应该只打印一次
</code></pre>
<p>下面讲解一下为什么会出现AtomicStampedRerence和AtomicMarkableReference；这俩个类。</p>
<p>这就要引出CAS会出现的一个问题，上面讲解了一下什么是ABA问题，这里在来重复讲解什么是ABA问题呢，当某些流程在处理过程中是顺向的，也就是不允许重复处理的情况下，在某些情况下导致一个数据由A变成B，再中间可能经过0-N个环节后变成了A，此时A不允许再变成B了，因为此时的状态已经发生了改变，例如：银行资金里面做一批账目操作，要求资金在80-100元的人，增加20元钱，时间持续一天，也就是后台程序会不断扫描这些用户的资金是否是在这个范围，但是要求增加过的人就不能再增加了，如果增加20后，被人取出10元继续在这个范围，那么就可以无限套现出来，就是ABA问题了，类似的还有抢红包或中奖，比如每天每个人限量3个红包，中那个等级的奖的个数等等。</p>
<p>下面一个例子是ABA问题的简单演示：</p>
<pre><code class="java">
import java.util.concurrent.atomic.AtomicReference;  

/** 
* ABA问题模拟，线程并发中，导致ABA问题，解决方案是使用|AtomicMarkableReference 
* 请参看相应的例子：AtomicStampedReferenceTest、AtomicMarkableReferenceTest 
* 
*/  
public class AtomicReferenceABATest {  

public final static AtomicReference &lt;String&gt;ATOMIC_REFERENCE = new AtomicReference&lt;String&gt;(&quot;abc&quot;);  

public static void main(String []args) {  
  for(int i = 0 ; i &lt; 100 ; i++) {  
      final int num = i;  
      new Thread() {  
          public void run() {  
              try {  
                  Thread.sleep(Math.abs((int)(Math.random() * 100)));  
              } catch (InterruptedException e) {  
                  e.printStackTrace();  
              }  
              if(ATOMIC_REFERENCE.compareAndSet(&quot;abc&quot; , &quot;abc2&quot;)) {  
                  System.out.println(&quot;我是线程：&quot; + num + 
                           &quot;,我获得了锁进行了对象修改！&quot;);  
              }  
          }  
      }.start();  
  }  
  new Thread() {  
      public void run() {  
          while(!ATOMIC_REFERENCE.compareAndSet(&quot;abc2&quot;, &quot;abc&quot;));  
          System.out.println(&quot;已经改为原始值！&quot;);  
      }  
  }.start();  
}  
}
</code></pre>
<p>代码中和原来的例子，唯一的区别就是最后增加了一个线程让他将数据修改为原来的值，并一直尝试修改，直到修改成功为止。</p>
<p><strong>此时我们得到的结果是:</strong></p>
<pre><code>我是线程：41,我获得了锁进行了对象修改！
已经改为原始值！
我是线程：85,我获得了锁进行了对象修改！
</code></pre><p>当然你的线程编号多半和我不一样,但是最后结果都会差不多，可以发现，有两个线程修改了这个字符串，我们是想那一堆将abc改成abc2的线程仅有一个成功，即使其他线程在他们运行时将引用值修改为abc，也不能再修改。</p>
<p>下面来讲解如何来解决这个问题，此时我们需要使用的方式就不是简单的compareAndSet操作，因为它仅仅是考虑到物理上的并发，而不是在业务逻辑上去控制顺序，此时我们需要借鉴数据库的事务序列号的一些思想来解决，假如每个对象修改的次数可以记住，修改前先对比下次数是否一致再修改，那么这个问题就简单了，AtomicStampedReference类正是提供这一功能的，其实它仅仅是在AtomicReference类的再一次包装，里面增加了一层引用和计数器，其实是否为计数器完全由自己控制，大多数我们是让他自增的，你也可以按照自己的方式来标示版本号，</p>
<p>此时我们通过类来AtomicStampedReference解决这个问题：</p>
<pre><code class="java">import java.util.concurrent.atomic.AtomicStampedReference;  

public class AtomicStampedReferenceTest {  

public final static AtomicStampedReference &lt;String&gt;ATOMIC_REFERENCE = 
     new AtomicStampedReference&lt;String&gt;(&quot;abc&quot; , 0);  

public static void main(String []args) {  
  for(int i = 0 ; i &lt; 100 ; i++) {  
      final int num = i;  
      final int stamp = ATOMIC_REFERENCE.getStamp();  
      new Thread() {  
          public void run() {  
              try {  
                  Thread.sleep(Math.abs((int)(Math.random() * 100)));  
              } catch (InterruptedException e) {  
                  e.printStackTrace();  
              }  
              if(ATOMIC_REFERENCE.compareAndSet(&quot;abc&quot; , &quot;abc2&quot; ,
                          stamp , stamp + 1)) {  
                  System.out.println(&quot;我是线程：&quot; + num + 
                              &quot;,我获得了锁进行了对象修改！&quot;);  
              }  
          }  
      }.start();  
  }  
  new Thread() {  
      public void run() {  
          int stamp = ATOMIC_REFERENCE.getStamp();  
          while(!ATOMIC_REFERENCE.compareAndSet(&quot;abc2&quot;, &quot;abc&quot; , 
                      stamp , stamp + 1));  
          System.out.println(&quot;已经改回为原始值！&quot;);  
      }  
  }.start();  
}  
}
</code></pre>
<p>此时再运行程序看到的结果就是我们想要的了，发现将abc修改为abc2的线程仅有一个被访问，虽然被修改回了原始值，但是其他线程也不会再将abc改为abc2。因为我们在修改引用对象时，会首先检测版本号是不是相同的，也就是当前<strong>stamp</strong>是不是和给定的相同，如果不同即使引用对象相同也不修改。这样就避免了ABA问题。</p>
<p><strong>AtomicMarkableReference</strong>和<strong>AtomicStampedReference</strong>功能差不多，有点区别的是：它描述更加简单的是与否的关系，通常ABA问题只有两种状态，而<strong>AtomicStampedReference</strong>是多种状态，那么为什么还要有<strong>AtomicMarkableReference</strong>呢，因为它在处理是与否上面更加具有可读性，而<strong>AtomicStampedReference</strong>过于随意定义状态，并不便于阅读大量的是和否的关系，它可以被认为是一个计数器或状态列表等信息，java提倡通过类名知道其意义，所以这个类的存在也是必要的，它的定义就是将数据变换为true|false如下：</p>
<pre><code class="Java">public final static AtomicMarkableReference &lt;String&gt;ATOMIC_MARKABLE_REFERENCE = 
  new AtomicMarkableReference&lt;String&gt;(&quot;abc&quot; , false);
</code></pre>
<p>操作时使用</p>
<pre><code>ATOMIC_MARKABLE_REFERENCE.compareAndSet(&quot;abc&quot;, &quot;abc2&quot;, false, true);
</code></pre></blockquote>
<h3 id="数组类型解析以及使用"><a href="#数组类型解析以及使用" class="headerlink" title="数组类型解析以及使用"></a>数组类型解析以及使用</h3><blockquote>
<p>数组原子类型主要有这几个类：AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray</p>
<p>下面是AtomicIntegerArray的一个测试例子：</p>
<pre><code class="java">import java.util.concurrent.atomic.AtomicIntegerArray;  

public class AtomicIntegerArrayTest {  

/** 
   * 常见的方法列表 
   * @see AtomicIntegerArray#addAndGet(int, int) 执行加法，第一个参数为数组的下标，第二个参数为增加的数量，返回增加后的结果 
   * @see AtomicIntegerArray#compareAndSet(int, int, int) 对比修改，参数1：数组下标，参数2：原始值，参数3，修改目标值，修改成功返回true否则false 
   * @see AtomicIntegerArray#decrementAndGet(int) 参数为数组下标，将数组对应数字减少1，返回减少后的数据 
   * @see AtomicIntegerArray#incrementAndGet(int) 参数为数组下标，将数组对应数字增加1，返回增加后的数据 
   *  
   * @see AtomicIntegerArray#getAndAdd(int, int) 和addAndGet类似，区别是返回值是变化前的数据 
   * @see AtomicIntegerArray#getAndDecrement(int) 和decrementAndGet类似，区别是返回变化前的数据 
   * @see AtomicIntegerArray#getAndIncrement(int) 和incrementAndGet类似，区别是返回变化前的数据 
   * @see AtomicIntegerArray#getAndSet(int, int) 将对应下标的数字设置为指定值，第二个参数为设置的值，返回是变化前的数据 
*/  
private final static AtomicIntegerArray ATOMIC_INTEGER_ARRAY = new AtomicIntegerArray(new int[]{1,2,3,4,5,6,7,8,9,10});  

public static void main(String []args) throws InterruptedException {  
  Thread []threads = new Thread[100];  
  for(int i = 0 ; i &lt; 100 ; i++) {  
      final int index = i % 10;  
      final int threadNum = i;  
      threads[i] = new Thread() {  
          public void run() {  
              int result = ATOMIC_INTEGER_ARRAY.addAndGet(index, index + 1);  
              System.out.println(&quot;线程编号为：&quot; + 
                                 threadNum + &quot; , 对应的原始值为：&quot; + 
                                  (index + 1) + &quot;，增加后的结果为：&quot; + result);  
          }  
      };  
      threads[i].start();  
  }  
  for(Thread thread : threads) {  
      thread.join();  
  }  
  System.out.println(&quot;=========================&gt;\n执行已经完成，结果列表：&quot;);  
  for(int i = 0 ; i &lt; ATOMIC_INTEGER_ARRAY.length() ; i++) {  
      System.out.println(ATOMIC_INTEGER_ARRAY.get(i));  
  }  
}  
} 
</code></pre>
<p>计算结果说明：100个线程并发，每10个线程会被并发修改数组中的一个元素，也就是数组中的每个元素会被10个线程并发修改访问，每次增加原始值的大小，此时运算完的结果看最后输出的敲好为原始值的11倍数，和我们预期的一致，如果不是线程安全那么这个值什么都有可能。</p>
<p>而相应的类：<strong>AtomicLongArray</strong>其实和<strong>AtomicIntegerArray</strong>操作方法类似，最大区别就是它操作的数据类型是long；而AtomicRerenceArray也是这样,只是他操作的是对象，没有了自增和自减这些操作。</p>
</blockquote>
<h3 id="属性原子修改器-Updater-解析以及使用"><a href="#属性原子修改器-Updater-解析以及使用" class="headerlink" title="属性原子修改器(Updater)解析以及使用"></a>属性原子修改器(Updater)解析以及使用</h3><blockquote>
<p>Atomic系列是为你定义好的一些对象，你可以使用，但是如果是别人已经在使用的对象会原先的代码需要修改为Atomic系列，此时若全部修改类型到对应的对象相信很麻烦，因为牵涉的代码会很多，此时java提供一个外部的Updater可以对对象的属性本身的修改提供类似Atomic的操作，也就是它对这些普通的属性的操作是并发下安全的，分别由：<strong>AtomicIntegerFieldUpdater、AtomicLongFieldUpdater、AtomicReferenceUpdater</strong>，这样操作后，系统会更加灵活，也就是可能那些类的属性只是在某些情况下需要控制并发，很多时候不需要，但是他们的使用通常有以下几个限制：</p>
<p><strong>限制1：</strong>操作的目标<strong>不能是static</strong>类型，前面说到unsafe的已经可以猜测到它提取的是非static类型的属性偏移量，如果是static类型在获取时如果没有使用对应的方法是会报错的，而这个Updater并没有使用对应的方法。</p>
<p><strong>限制2：</strong>操作的目标<strong>不能是final</strong>类型的，因为final根本没法修改。</p>
<p><strong>限制3：必须是volatile</strong>类型的数据，也就是数据本身是读一致的。</p>
<p><strong>限制4：</strong>属性必须对当前的<strong>Updater所在的区域是可见的</strong>，也就是<strong>private</strong>如果不是当前类肯定是不可见的，<strong>protected</strong>如果不存在父子关系也是不可见的，<strong>default</strong>如果不是在同一个<strong>package</strong>下也是不可见的。</p>
<p><strong>实现方式：</strong>通过反射找到属性，对属性进行操作，但是并不是设置accessable，所以必须是可见的属性才能操作。</p>
<pre><code>import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;  

public class AtomicIntegerFieldUpdaterTest {  

static class A {  
  volatile int intValue = 100;  
}  

/** 
   * 可以直接访问对应的变量，进行修改和处理 
   * 条件：要在可访问的区域内，如果是private或挎包访问default类型以及非父亲类的protected均无法访问到 
   * 其次访问对象不能是static类型的变量（因为在计算属性的偏移量的时候无法计算），也不能是final类型的变量（因为根本无法修改），必须是普通的成员变量 
   *  
   * 方法（说明上和AtomicInteger几乎一致，唯一的区别是第一个参数需要传入对象的引用） 
   * @see AtomicIntegerFieldUpdater#addAndGet(Object, int) 
   * @see AtomicIntegerFieldUpdater#compareAndSet(Object, int, int) 
   * @see AtomicIntegerFieldUpdater#decrementAndGet(Object) 
   * @see AtomicIntegerFieldUpdater#incrementAndGet(Object) 
   *  
   * @see AtomicIntegerFieldUpdater#getAndAdd(Object, int) 
   * @see AtomicIntegerFieldUpdater#getAndDecrement(Object) 
   * @see AtomicIntegerFieldUpdater#getAndIncrement(Object) 
   * @see AtomicIntegerFieldUpdater#getAndSet(Object, int) 
*/  
public final static AtomicIntegerFieldUpdater &lt;A&gt;ATOMIC_INTEGER_UPDATER = AtomicIntegerFieldUpdater.newUpdater(A.class, &quot;intValue&quot;);  

public static void main(String []args) {  
  final A a = new A();  
  for(int i = 0 ; i &lt; 100 ; i++) {  
      final int num = i;  
      new Thread() {  
          public void run() {  
              if(ATOMIC_INTEGER_UPDATER.compareAndSet(a, 100, 120)) {  
                  System.out.println(&quot;我是线程：&quot; + num + 
                                  &quot; 我对对应的值做了修改！&quot;);  
              }  
          }  
      }.start();  
  }  
}  
}  
</code></pre><p>此时你会发现只有一个线程可以对这个数据进行修改，其他的方法如上面描述一样，实现的功能和AtomicInteger类似。</p>
<p>而<strong>AtomicLongFieldUpdater</strong>其实也是这样，区别在于它所操作的数据是long类型。</p>
<p><strong>AtomicReferenceFieldUpdater</strong>方法较少，主要是<strong>compareAndSet</strong>以及<strong>getAndSet</strong>两个方法的使用，它的定义比数字类型的多一个参数如下：</p>
<pre><code class="java">static class A {  
volatile String stringValue = &quot;abc&quot;;  
}  

AtomicReferenceFieldUpdater &lt;A ,String&gt;ATOMIC_REFERENCE_FIELD_UPDATER =    AtomicReferenceFieldUpdater.newUpdater(A.class, String.class, &quot;stringValue&quot;);  
</code></pre>
</blockquote>
<h3 id="Java-8新增加的LongAdder等类的解析以及使用"><a href="#Java-8新增加的LongAdder等类的解析以及使用" class="headerlink" title="Java 8新增加的LongAdder等类的解析以及使用"></a>Java 8新增加的LongAdder等类的解析以及使用</h3><blockquote>
<p>DoubleAccumulator、LongAccumulator、DoubleAdder、LongAdder是JDK1.8新增的部分，是对AtomicLong等类的改进。</p>
<p>在CAS介绍那一节已经介绍了CAS存在的问题，前面解决了ABA问题，单丝还有一个问题没解决，就是在高并发的情况下会出现CAS频繁碰撞，碰撞会造成赋值失败继续重试，越多线程重试，CAS失败几率又越高，变成恶性循环，造成效率底下等问题；</p>
<p>为了解决AutomicInteger等原子操作类在高并发下的性能问题，JDK8添加了LongAdder和DoubleAdder高并发增强原子类，其基本思想就是对于多个线程对同一个变量操作不相互排斥，而是保存每个线程对变量的修改，在读取变量的时候进行汇总，这样就不会造成线程间的互斥和重试，极大提高想并发性能；</p>
<pre><code>//主要API

//构造函数
LongAdder()
//创建初始和为零的新加法器。

//方法摘要
void    add(long x)
//添加给定的值。
void    decrement()
//相当于add(-1)。
double  doubleValue()
//在扩展原始转换之后返回sum()as double。
float   floatValue()
//在扩展原始转换之后返回sum()as float。
void    increment()
//相当于add(1)。
int intValue()
//返回sum()作为int一个基本收缩转换之后。
long    longValue()
//相当于sum()。
void    reset()
//重置将总和保持为零的变量。
long    sum()
//返回当前的总和。
long    sumThenReset()
//等同于sum()后面的效果reset()。
String  toString()
//返回。的字符串表示形式sum()。
</code></pre><p><strong>实现原理：</strong></p>
<p>LongAdder继承了Striped64类，来实现累加功能的,它是实现高并发累加的工具类； </p>
<ul>
<li>Striped64的设计核心思路就是通过内部的分散计算来避免竞争。 </li>
<li>Striped64内部包含一个base和一个Cell[] cells数组，又叫hash表。 </li>
<li>没有竞争的情况下，要累加的数通过cas累加到base上；如果有竞争的话，会将要累加的数累加到Cells数组中的某个cell元素里面。所以整个Striped64的值为sum=base+∑[0~n]cells。</li>
</ul>
<p>LongAdder这样的处理方式是有坏处的，分段操作必然带来空间上的浪费，可以空间换时间；</p>
<p>AtomicInteger和LongAdder的速度关系是： 低并发时LongAdder和AtomicLong性能差不多，高并发时LongAdder更高效</p>
</blockquote>

          
        
      
    </div>

    

    
    
    

      

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="枫秀天涯">
            
              <p class="site-author-name" itemprop="name">枫秀天涯</p>
              <p class="site-description motion-element" itemprop="description">java,spring,分布式,数据库</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">155</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">41</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">80</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="https://github.com/fengxiutianya" title="GitHub &rarr; https://github.com/fengxiutianya" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i></a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="mailto:398757724@qq.com" title="E-Mail &rarr; mailto:398757724@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i></a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 – <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">枫秀天涯</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      
      网站总字数
    </span>
    
    <span title="站点总字数">1.3m</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      
      总阅读时长
    </span>
    
    <span title="站点阅读时长">19:36</span>
  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>







  








  
    
    
  
  <script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script>











  



  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script src="/lib/reading_progress/reading_progress.js"></script>


  


  <script src="/js/src/utils.js?v=6.7.0"></script>

  <script src="/js/src/motion.js?v=6.7.0"></script>



  
  


  <script src="/js/src/affix.js?v=6.7.0"></script>

  <script src="/js/src/schemes/pisces.js?v=6.7.0"></script>



  

  


  <script src="/js/src/bootstrap.js?v=6.7.0"></script>



  

  
    <script id="dsq-count-scr" src="https://fengxiutianya.disqus.com/count.js" async></script>
  

  













  




  
  
  
  <link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">

  
  
  <script src="/lib/algolia-instant-search/instantsearch.min.js"></script>
  

  <script src="/js/src/algolia-search.js?v=6.7.0"></script>



  

  
  <script>
    
    function showTime(Counter) {
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      Counter('get', '/classes/Counter', { where: JSON.stringify({ url: { "$in": entries } }) })
        .done(function ({ results }) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.url;
            var time = item.time;
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function ({ responseJSON }) {
          console.log("LeanCloud Counter Error: " + responseJSON.code + " " + responseJSON.error);
        });
    }
    

    $(function() {
      $.get('https://app-router.leancloud.cn/2/route?appId=' + "8rM8gj5HTRTSqBQdFyePed86-gzGzoHsz")
        .done(function ({ api_server }) {
          var Counter = function (method, url, data) {
            return $.ajax({
              method: method,
              url: `https://${api_server}/1.1${url}`,
              headers: {
                'X-LC-Id': "8rM8gj5HTRTSqBQdFyePed86-gzGzoHsz",
                'X-LC-Key': "f92qb0ijeNp2joqk3ld6IlRW",
                'Content-Type': 'application/json',
              },
              data: data,
            });
          };
          
          if ($('.post-title-link').length >= 1) {
            showTime(Counter);
          }
          
        })
    });
  </script>



  

  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>


  

  
  

  
  
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  

  


  

  

  

  

  

  

  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      background-color: #eee;
      background-image: linear-gradient(#fcfcfc, #eee);
      border: 1px solid #d5d5d5;
      border-radius: 3px;
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      right: 4px;
      top: 8px;
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1
    }

    .highlight-wrap {
      position: relative;
    }
  </style>
  <script>
    $('.highlight').each(function (i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap');
      $(e).after($wrap);
      $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function (e) {
        var code = $(this).parent().find('.code').find('.line').map(function (i, e) {
          return $(e).text();
        }).toArray().join('\n');
        var ta = document.createElement('textarea');
        var range = document.createRange(); //For Chrome
        var sel = window.getSelection(); //For Chrome
        var yPosition = window.pageYOffset || document.documentElement.scrollTop;
        ta.style.top = yPosition + 'px'; //Prevent page scroll
        ta.style.position = 'absolute';
        ta.style.opacity = '0';
        ta.value = code;
        ta.textContent = code; //For FireFox
        ta.contentEditable = true;
        ta.readOnly = false;
        document.body.appendChild(ta);
        range.selectNode(ta);
        sel.removeAllRanges();
        sel.addRange(range);
        ta.setSelectionRange(0, code.length);
        var result = document.execCommand('copy');
        
          if (result) $(this).text('复制成功');
          else $(this).text('复制失败');
        
        ta.blur(); //For iOS
        $(this).blur();
      })).on('mouseleave', function (e) {
        var $b = $(this).find('.copy-btn');
        setTimeout(function () {
          $b.text('复制');
        }, 300);
      }).append(e);
    })
  </script>


  

  
  
  

  <link rel="stylesheet" href="/lib/prettify/themes/atelier-estuary-light.min.css" type="text/css">

<script src="/lib/prettify/prettify.js"></script>
<script type="text/javascript">
$(window).load(function(){
  // 设置prettify
  $('pre').addClass('prettyprint linenums');
   prettyPrint();
 })
</script>
<style>
pre {
  white-space:pre;
  white-space:pre-wrap;
  word-break:break-all;
  word-wrap:break-word;
}
</style>




</body>
</html>
