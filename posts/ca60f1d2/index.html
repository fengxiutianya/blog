<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
    
      
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/themes/blue/pace-theme-minimal.css">























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=6.7.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.7.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.7.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.7.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.7.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.7.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: 'AQT4XGM95O',
      apiKey: 'd55e0adb332e8d9ef9023a6b4afd46f1',
      indexName: 'my',
      hits: {"per_page":10},
      labels: {"input_placeholder":"请输入搜索内容","hits_empty":"没有发现和 ${query} 有关的内容","hits_stats":"在 ${time} ms 内发现 ${hits} "}
    }
  };
</script>


  




  <meta name="description" content="java多线程系列-JUC线程池之02 ThreadPoolExecutor 执行流程分析概要  线程池使用例子 线程池状态 任务执行流程分析">
<meta name="keywords" content="JUC,线程池">
<meta property="og:type" content="article">
<meta property="og:title" content="java多线程系列-JUC线程池之02 ThreadPoolExecutor 执行流程分析">
<meta property="og:url" content="http://fengxiutianya.top/posts/ca60f1d2/index.html">
<meta property="og:site_name" content="枫秀天涯">
<meta property="og:description" content="java多线程系列-JUC线程池之02 ThreadPoolExecutor 执行流程分析概要  线程池使用例子 线程池状态 任务执行流程分析">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-04-18T13:10:27.792Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java多线程系列-JUC线程池之02 ThreadPoolExecutor 执行流程分析">
<meta name="twitter:description" content="java多线程系列-JUC线程池之02 ThreadPoolExecutor 执行流程分析概要  线程池使用例子 线程池状态 任务执行流程分析">






  <link rel="canonical" href="http://fengxiutianya.top/posts/ca60f1d2/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>java多线程系列-JUC线程池之02 ThreadPoolExecutor 执行流程分析 | 枫秀天涯</title>
  




  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-136781627-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'UA-136781627-1');
  </script>









  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">枫秀天涯</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  
    <div class="reading-progress-bar"></div>
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fengxiutianya.top/posts/ca60f1d2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="枫秀天涯">
      <meta itemprop="description" content="java,spring,分布式,数据库">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="枫秀天涯">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">java多线程系列-JUC线程池之02 ThreadPoolExecutor 执行流程分析

              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-07-23 14:35:00" itemprop="dateCreated datePublished" datetime="2018-07-23T14:35:00+08:00">2018-07-23</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-18 21:10:27" itemprop="dateModified" datetime="2019-04-18T21:10:27+08:00">2019-04-18</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/juc/" itemprop="url" rel="index"><span itemprop="name">juc</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/juc/Executors/" itemprop="url" rel="index"><span itemprop="name">Executors</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/posts/ca60f1d2/#comments" itemprop="discussionUrl">
                
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="posts/ca60f1d2/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/posts/ca60f1d2/" class="leancloud_visitors" data-flag-title="java多线程系列-JUC线程池之02 ThreadPoolExecutor 执行流程分析">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">16k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">15 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="java多线程系列-JUC线程池之02-ThreadPoolExecutor-执行流程分析"><a href="#java多线程系列-JUC线程池之02-ThreadPoolExecutor-执行流程分析" class="headerlink" title="java多线程系列-JUC线程池之02 ThreadPoolExecutor 执行流程分析"></a>java多线程系列-JUC线程池之02 ThreadPoolExecutor 执行流程分析</h1><h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><blockquote>
<ol>
<li>线程池使用例子</li>
<li>线程池状态</li>
<li>任务执行流程分析<a id="more"></a>
</li>
</ol>
</blockquote>
<h3 id="1-线程池使用例子"><a href="#1-线程池使用例子" class="headerlink" title="1. 线程池使用例子"></a>1. 线程池使用例子</h3><blockquote>
<p>简单例子</p>
<pre><code>import java.util.concurrent.Executors;
import java.util.concurrent.ExecutorService;

public class ThreadPoolDemo1 {

   public static void main(String[] args) {
       // 创建一个可重用固定线程数的线程池
       ExecutorService pool = Executors.newFixedThreadPool(2);
       // 创建实现了Runnable接口对象，Thread对象当然也实现了Runnable接口
       Thread ta = new MyThread();
       Thread tb = new MyThread();
       Thread tc = new MyThread();
       Thread td = new MyThread();
       Thread te = new MyThread();
       // 将线程放入池中进行执行
       pool.execute(ta);
       pool.execute(tb);
       pool.execute(tc);
       pool.execute(td);
       pool.execute(te);
       // 关闭线程池
       pool.shutdown();
   }
}

class MyThread extends Thread {

   @Override
   public void run() {
       System.out.println(Thread.currentThread().getName()+ &quot; is running.&quot;);
   }
}
</code></pre><p><strong>运行结果</strong>：</p>
<pre><code>pool-1-thread-1 is running.
pool-1-thread-2 is running.
pool-1-thread-1 is running.
pool-1-thread-2 is running.
pool-1-thread-1 is running.
</code></pre><p>示例中，使用了Excutors工具类来创建线程池，并提交任务到线程池上运行，然后关闭线程池，这是一个简单的实例。接下来我们将进行ThreadPoolExecutor深入分析。</p>
</blockquote>
<h3 id="2-线程池状态"><a href="#2-线程池状态" class="headerlink" title="2. 线程池状态"></a>2. 线程池状态</h3><blockquote>
<p>在线程池中使用了一个AtomicInteger对象来表示线程的状态和任务的数量。其中Integer是32位，用高三位来表示线程池的状态，至于怎么计算不是这里的重点，这里我们先讲解任务的状态。</p>
<p>线程池中任务的状态有以下5种：</p>
<pre><code>RUNNING   :接收新的任务和处理队列中的任务
SHUTDOWN  :不在接收新的任务和但是处理队列中的任务。
STOP        :不在接收新的任务，同时不在处理队列中的任务，线程上正在运行的任务也会被打断。
TIDYING   :所有的任务已经结束，并且线程的数量为0，线程的状态转换成清理的状态，接下来将会运行
           terminated()方法。
TERMINATED:terminated()执行完成
</code></pre><p>状态的转换:</p>
<pre><code>RUNNING -&gt; SHUTDOWN：调用 shutdown()方法后，也会包含一些回收的处理
(RUNNING or SHUTDOWN) -&gt; STOP：调用shutdownNow()
SHUTDOWN -&gt; TIDYING：当线程池和任务队列都为空
STOP -&gt; TIDYING：当线程池为空
TIDYING -&gt; TERMINATED： 当terminated() 方法已经完成
</code></pre><p>具体的状态转换如上面所示。另外线程池的状态是通过比特为来表示的，使用ctl这个原子变量的高三位来确定的。具体的如下所示。</p>
<pre><code class="java">private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;
private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;
private static final int STOP       =  1 &lt;&lt; COUNT_BITS;
private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;
private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;
</code></pre>
</blockquote>
<h3 id="3-线程池执行任务分析"><a href="#3-线程池执行任务分析" class="headerlink" title="3. 线程池执行任务分析"></a>3. 线程池执行任务分析</h3><blockquote>
<p>在讲解运行过程前，我们先看下<code>ThreadPoolExecutor</code>中的几个比较重要的成员变量：</p>
<pre><code class="java">// 高三位表示当前线程池的状态，低29为表示线程的数量,所以线程的数量最大是(2^29)-1
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));

// 任务队列
private final BlockingQueue&lt;Runnable&gt; workQueue;

// 用于同步线程池，也就是线面对workers的操作
private final ReentrantLock mainLock = new ReentrantLock();

// 线程池存放线程的地点
private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;();

// 用于支持awaitTermination的等待条件
private final Condition termination = mainLock.newCondition();

// 记录线程池中同时存在的最大线程数的历史记录
private int largestPoolSize;

//完成任务的数量，在工作线程结束时才会进行更新
private long completedTaskCount

// 创建线程的工厂
private volatile ThreadFactory threadFactory;

// 线程池的拒绝策略
private volatile RejectedExecutionHandler handler;

// 线程空闲的最大时间，如果超过这个会关闭这个线程，
// 和下面的allowCoreThreadTimeOut一起使用
private volatile long keepAliveTime;

// true 核心线程也可以被关闭，false，核心线程不能被关闭
private volatile boolean allowCoreThreadTimeOut;

// 核心线程的大小
private volatile int corePoolSize;

//最大线程的数量
private volatile int maximumPoolSize;
</code></pre>
<p>这边重点解释下 <code>corePoolSize</code>、<code>maximumPoolSize</code>、<code>workQueue</code>两个变量，这两个变量涉及到线程池中创建线程个数的一个策略。<br><code>corePoolSize</code>： 这个变量我们可以理解为线程池的核心大小，举个例子来说明（corePoolSize假设等于10，maximumPoolSize等于20）：</p>
<ol>
<li>有一个部门，其中有10（corePoolSize）名工人，当有新任务来了后，领导就分配任务给工人去做，每个工人只能做一个任务。</li>
<li>当10个工人都在忙时，新来的任务就要放到队列（workQueue）中等待。</li>
<li>当任务越积累越多，远远超过工人做任务的速度时，领导就想了一个办法：从其他部门借10个工人来，借的数量有一个公式（maximumPoolSize - corePoolSize）来计算。然后把新来的任务分配给借来的工人来做。</li>
<li>但是如果速度还是还不急的话，可能就要采取措施来放弃一些任务了（RejectedExecutionHandler）。<br>等到一定时间后，任务都完成了，工人比较闲的情况下，就考虑把借来的10个工人还回去（根据keepAliveTime判断）</li>
<li>也就是说corePoolSize就是线程池大小，maximumPoolSize在我看来是线程池的一种补救措施，即任务量突然过大时的一种补救措施。</li>
</ol>
<h3 id="任务执行：execute"><a href="#任务执行：execute" class="headerlink" title="任务执行：execute"></a>任务执行：execute</h3><p>这个方法在ThreadPoolExecutor中的源码如下</p>
<pre><code class="java">public void execute(Runnable command) {
   //如果任务是空，则抛出空指针异常
  if (command == null)
      throw new NullPointerException();
   //得到当前ctl的值，方便下面计算    
  int c = ctl.get();
   //计算当前线程池中线程的数量，如果小于核心线程数，则添加线程
  if (workerCountOf(c) &lt; corePoolSize) {
      // 则通过addWorker(command, true)新建一个线程，并将任务(command)添加到该线程
      //中；然后，启动该线程从而执行任务。
      if (addWorker(command, true))
          return;
      c = ctl.get();
  }
   // 当线程池中的任务数量 &gt;= &quot;核心池大小&quot;时，
    // 而且，&quot;线程池处于运行状态&quot;时，则尝试将任务添加到阻塞队列中。
  if (isRunning(c) &amp;&amp; workQueue.offer(command)) {
       // 再次确认“线程池状态”，若线程池异常终止了，则删除任务；
      //然后通过reject()执行相应的拒绝策略的内容。
      int recheck = ctl.get();
      if (! isRunning(recheck) &amp;&amp; remove(command))
          reject(command);
      // 否则，如果&quot;线程池中任务数量&quot;为0，则通过addWorker(null, false)尝试新建一个线
      // 程，新建线程对应的任务为null。防止线程池被关闭
      else if (workerCountOf(recheck) == 0)
          addWorker(null, false);
  }
 //这里是启动小于maxpoolSize的线程
 //如果添加任务到队列中不成功，则试图通过addWorker(command, false)新建一个线程，
 //并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。
 // 如果addWorker(command, false)执行失败，则通过reject()执行相应的拒绝策略的内容。
  else if (!addWorker(command, false))
      reject(command);
}
}
</code></pre>
<p><strong>说明</strong>：execute()的作用是将任务添加到线程池中执行。它会分为3种情况进行处理：        </p>
<p><strong>情况1</strong> – 如果”线程池中任务数量” &lt; “核心池大小”时，即线程池中少于corePoolSize个任务；此时就新建一个线程，并将该任务添加到线程中进行执行。         </p>
<p><strong>情况2</strong> – 如果”线程池中任务数量” &gt;= “核心池大小”，并且”线程池是允许状态”；此时，则将任务添加到阻塞队列中阻塞等待。在该情况下，会再次确认”线程池的状态”，如果”第2次读到的线程池状态”和”第1次读到的线程池状态”不同，则从阻塞队列中删除该任务。         </p>
<p><strong>情况3</strong> – 非以上两种情况。在这种情况下，尝试新建一个线程，并将该任务添加到线程中进行执行。如果执行失败，则通过reject()拒绝该任务。</p>
<p>到这里，大部分朋友应该对任务提交给线程池之后到被执行的整个过程有了一个基本的了解，下面总结一下：</p>
<ol>
<li>首先，要清楚corePoolSize和maximumPoolSize的含义；</li>
<li>其次，要知道Worker是用来起到什么作用的；</li>
<li>要知道任务提交给线程池之后的处理策略，这里总结一下主要有4点：</li>
</ol>
<ul>
<li>如果当前线程池中的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；</li>
<li>如果当前线程池中的线程数目&gt;=corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务；</li>
<li>如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理；</li>
<li>如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于 corePoolSize；如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过keepAliveTime，线程也会被终止。</li>
</ul>
<h3 id="addWorker"><a href="#addWorker" class="headerlink" title="addWorker"></a><strong>addWorker</strong></h3><p>源码如下</p>
<pre><code class="java">private boolean addWorker(Runnable firstTask, boolean core) {
  retry:
  // 更新&quot;线程池状态和计数&quot;标记，即更新ctl。
  for (;;) {
     // 更新&quot;线程池状态和计数&quot;标记，即更新ctl。
      int c = ctl.get();
       // 获取线程池状态。
      int rs = runStateOf(c);

      // Check if queue empty only if necessary.
      // 有效性检查
      if (rs &gt;= SHUTDOWN &amp;&amp;
          ! (rs == SHUTDOWN &amp;&amp;
             firstTask == null &amp;&amp;
             ! workQueue.isEmpty()))
          return false;

      for (;;) {
         // 获取线程池中任务的数量。
          int wc = workerCountOf(c);
          // 如果&quot;线程池中任务的数量&quot;超过限制，则返回false。
          if (wc &gt;= CAPACITY ||
              wc &gt;= (core ? corePoolSize : maximumPoolSize))
              return false;
          // 通过CAS函数将c的值+1。操作失败的话，则退出循环。
          if (compareAndIncrementWorkerCount(c))
              break retry;
          c = ctl.get();  // Re-read ctl
          // 检查&quot;线程池状态&quot;，如果与之前的状态不同，则从retry重新开始。
          if (runStateOf(c) != rs)
              continue retry;
          // else CAS failed due to workerCount change; retry inner loop
      }
  }

boolean workerStarted = false;
boolean workerAdded = false;
Worker w = null;
// 添加任务到线程池，并启动任务所在的线程。
try {
  final ReentrantLock mainLock = this.mainLock;
  // 新建Worker，并且指定firstTask为Worker的第一个任务。
  w = new Worker(firstTask);
  // 获取Worker对应的线程。
  final Thread t = w.thread;
  if (t != null) {
      // 获取锁
      mainLock.lock();
      try {
          int c = ctl.get();
          int rs = runStateOf(c);

          // 再次确认&quot;线程池状态&quot;
          if (rs &lt; SHUTDOWN ||
              (rs == SHUTDOWN &amp;&amp; firstTask == null)) {
              if (t.isAlive()) // precheck that t is startable
                  throw new IllegalThreadStateException();
              // 将Worker对象(w)添加到&quot;线程池的Worker集合(workers)&quot;中
              workers.add(w);
              // 更新largestPoolSize
              int s = workers.size();
              if (s &gt; largestPoolSize)
                  largestPoolSize = s;
              workerAdded = true;
          }
      } finally {
          // 释放锁
          mainLock.unlock();
      }
      // 如果&quot;成功将任务添加到线程池&quot;中，则启动任务所在的线程。 
      if (workerAdded) {
          t.start();
          workerStarted = true;
      }
  }
} finally {
  if (! workerStarted)
      addWorkerFailed(w);
}
// 返回任务是否启动。
return workerStarted;
}

</code></pre>
<p><strong>说明</strong>：</p>
<ol>
<li><p>addWorker(Runnable firstTask, boolean core) 的作用是将任务(firstTask)添加到线程池中，并启动该任务。core为true的话，则以corePoolSize为界限，若”线程池中已有任务数量&gt;=corePoolSize”，则返回false；core为false的话，则以maximumPoolSize为界限，若”线程池中已有任务数量&gt;=maximumPoolSize”，则返回false。</p>
</li>
<li><p>addWorker()会先通过for循环不断尝试更新ctl状态，ctl记录了”线程池中任务数量和线程池状态”。更新成功之后，再通过try模块来将任务添加到线程池中，并启动任务所在的线程。</p>
</li>
<li><p>从addWorker()中，我们能清晰的发现：线程池在添加任务时，会创建任务对应的Worker对象；而一个Workder对象包含一个Thread对象。</p>
</li>
</ol>
<p>(01) 通过将Worker对象添加到”线程的workers集合”中，从而实现将任务添加到线程池中。</p>
<p>(02) 通过启动Worker对应的Thread线程，则执行该任务。</p>
<h3 id="addWorkerFailed"><a href="#addWorkerFailed" class="headerlink" title="addWorkerFailed:"></a>addWorkerFailed:</h3><p>如果Worker创建成功，但是没有启动，这时我们需要将从线程对象从works上移除，否则会影响线程池的性能，源码如下</p>
<pre><code class="java">/**
   * Rolls back the worker thread creation.
   * - removes worker from workers, if present
   * - decrements worker count
   * - rechecks for termination, in case the existence of this
   *   worker was holding up termination
*/
private void addWorkerFailed(Worker w) {

  final ReentrantLock mainLock = this.mainLock;
  //获取锁
  mainLock.lock();
  try {
      //从workers上移除线程
      if (w != null)
          workers.remove(w);
      //减少线程的数量
      decrementWorkerCount();
      //由于线程数量的减少，可能会使得当前线程池上线程的数量变成0，这时有可能进入
      //TIDYING状态，所以尝试结束线程池
      tryTerminate();
  } finally {
      mainLock.unlock();
  }
}
</code></pre>
<p>这时你们会不会有个疑问，一般我们写程序时，如果想让线程一直运行，则会向下面这样写:</p>
<pre><code>public void run(){
while(true){
  //doSomething
}
}
</code></pre><p>但是上面执行流程分析完了，但是没看到ThreadPoolExecutor怎么定义线程一直运行，这时我们就要去分析Worker这个内部类的源码，这里面有我们想要的结果：</p>
<p>源码如下：</p>
<pre><code class="java">private final class Worker
  extends AbstractQueuedSynchronizer
  implements Runnable {      
  private static final long serialVersionUID = 6138294804551838833L;
       //当前woker正在运行的线程
  final Thread thread;
  //初始化这个工作线程时的第一个任务，可能为null
  Runnable firstTask;
     //每个线程完成任务的数量
  volatile long completedTasks;

  Worker(Runnable firstTask) {
      setState(-1); // inhibit interrupts until runWorker
      this.firstTask = firstTask;       
      //使用线程池提供的线程创建工厂来创建线程
      this.thread = getThreadFactory().newThread(this);
  }
  //委派当前线程的run方法到外部类的runWorker上，
  public void run() {
      runWorker(this);
  }
  // Lock methods
  //
  // The value 0 represents the unlocked state.
  // The value 1 represents the locked state.
  protected boolean isHeldExclusively() {
      return getState() != 0;
  }

  protected boolean tryAcquire(int unused) {
      if (compareAndSetState(0, 1)) {
          setExclusiveOwnerThread(Thread.currentThread());
          return true;
      }
      return false;
  }

  protected boolean tryRelease(int unused) {
      setExclusiveOwnerThread(null);
      setState(0);
      return true;
  }

  public void lock()        { acquire(1); }
  public boolean tryLock()  { return tryAcquire(1); }
  public void unlock()      { release(1); }
  public boolean isLocked() { return isHeldExclusively(); }

  void interruptIfStarted() {
      Thread t;
      if (getState() &gt;= 0 &amp;&amp; (t = thread) != null &amp;&amp; !t.isInterrupted()) {
          try {
              t.interrupt();
          } catch (SecurityException ignore) {
          }
      }
  }
}
</code></pre>
<p>分析：</p>
<ol>
<li>从上面我们可以看出，Worker继承AQS，实现Runnable接口，继承AQS实现了一个简单的互斥锁，是不想在Worker运行的时候使用外部类的互斥锁，这样可以减少线程的等待。</li>
<li>线程创建时通过外部类的threadFactory来创建的，后面我会讲解这个类，其实很简单</li>
</ol>
<p>从上面可以看出Worker类的run方法实现实际上是外部类的runWorker方法实现的，源码如下：</p>
<pre><code class="java">final void runWorker(Worker w) {
       //获取当前cpu上运行的线程，其实也就是worker中的thread
  Thread wt = Thread.currentThread();
   //获取第一个运行任务，可以为null
  Runnable task = w.firstTask;
  w.firstTask = null;
   //释放锁
  w.unlock(); // allow interrupts
   //判断当前线程是否是中断结束 true 不是
  boolean completedAbruptly = true;
  try {
      //当任务不为空，一直运行
      while (task != null || (task = getTask()) != null) {
          w.lock();
          // If pool is stopping, ensure thread is interrupted;
          // if not, ensure thread is not interrupted.  This
          // requires a recheck in second case to deal with
          // shutdownNow race while clearing interrupt
          if ((runStateAtLeast(ctl.get(), STOP) ||
               (Thread.interrupted() &amp;&amp;
                runStateAtLeast(ctl.get(), STOP))) &amp;&amp;
              !wt.isInterrupted())
              wt.interrupt();
          try {
              //hook方法，我们可以通过集成ThreadPoolExecutor来实现这个方法，
              //默认什么也不做
              beforeExecute(wt, task);
              Throwable thrown = null;
              try {
                  //执行任务
                  task.run();
              } catch (RuntimeException x) {
                  thrown = x; throw x;
              } catch (Error x) {
                  thrown = x; throw x;
              } catch (Throwable x) {
                  thrown = x; throw new Error(x);
              } finally {
                   //hook方法，我们可以通过集成ThreadPoolExecutor来实现这个方法，
                   //默认什么也不做
                  afterExecute(task, thrown);
              }
          } finally {
              task = null;
              w.completedTasks++;
              w.unlock();
          }
      }
      completedAbruptly = false;
  } finally {
      //线程死亡，使用此方法执行后续清理工作，
      processWorkerExit(w, completedAbruptly);
  }
}
</code></pre>
<p>从上面代码可以看到这边在循环获取任务，并执行，直到任务全部执行完毕。除了第一个任务，其他任务都是通过<code>getTask()</code>方法去取，这个方法是ThreadPoolExecutor中的一个方法。我们猜一下，整个类中只有任务缓存队列中保存了任务，应该就是去缓存队列中取了。</p>
<pre><code>Runnable getTask() {
for (;;) {
  try {
      int state = runState;
      if (state &gt; SHUTDOWN)
          return null;
      Runnable r;
      if (state == SHUTDOWN)  // Help drain queue
          r = workQueue.poll(); //取任务
      else if (poolSize &gt; corePoolSize || allowCoreThreadTimeOut) //如果线程数大于核心池大小或者允许为核心池线程设置空闲时间，
          //则通过poll取任务，若等待一定的时间取不到任务，则返回null
          r = workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS);
      else
          r = workQueue.take();
      if (r != null)
          return r;
      if (workerCanExit()) {    //如果没取到任务，即r为null，则判断当前的worker是否可以退出
          if (runState &gt;= SHUTDOWN) // Wake up others
              interruptIdleWorkers();   //中断处于空闲状态的worker
          return null;
      }
      // Else retry
  } catch (InterruptedException ie) {
      // On interruption, re-check runState
  }
}
}
</code></pre><p>这里有一个非常巧妙的设计方式，假如我们来设计线程池，可能会有一个任务分派线程，当发现有线程空闲时，就从任务缓存队列中取一个任务交给 空闲线程执行。但是在这里，并没有采用这样的方式，因为这样会要额外地对任务分派线程进行管理，无形地会增加难度和复杂度，这里直接让执行完任务的线程Worker去任务缓存队列里面取任务来执行，因为每一个Worker里面都包含了一个线程thread。</p>
<p>还需要注意的是，当线程死亡如何处理：</p>
<p>源码如下：</p>
<pre><code>   //处理线程结束时的清理工作
private void processWorkerExit(Worker w, boolean completedAbruptly) {
  //如果是中断结束，则线程数量不做调整
  if (completedAbruptly) 
      decrementWorkerCount();

  final ReentrantLock mainLock = this.mainLock;
  //获取锁
  mainLock.lock();
  try {
      //将当前worker线程上的完成任务数量记录下来
      completedTaskCount += w.completedTasks;
      //移除当前此worker
      workers.remove(w);
  } finally {
      mainLock.unlock();
  }
  //尝试关闭线程池
  tryTerminate();
  int c = ctl.get();
  //如果当前线程池状态不是stop，则添加woker线程
  if (runStateLessThan(c, STOP)) {
      //如果是异常导致线程的中断，则判断当前线程池中线程的
      //数量是否大于min，min表示当前线程池最少应该有多少线程
      //如果少于，则创建一个新的worker线程
      if (!completedAbruptly) {
          int min = allowCoreThreadTimeOut ? 0 : corePoolSize;
          if (min == 0 &amp;&amp; ! workQueue.isEmpty())
              min = 1;
          if (workerCountOf(c) &gt;= min)
              return; // replacement not needed
      }
      addWorker(null, false);
  }
}
</code></pre><h3 id="关闭“线程池”"><a href="#关闭“线程池”" class="headerlink" title="关闭“线程池”"></a>关闭“线程池”</h3><p>shutdown()的源码如下：</p>
<pre><code class="java">public void shutdown() {
final ReentrantLock mainLock = this.mainLock;
// 获取锁
mainLock.lock();
try {
  // 检查终止线程池的“线程”是否有权限。
  checkShutdownAccess();
  // 设置线程池的状态为关闭状态。
  advanceRunState(SHUTDOWN);
  // 中断线程池中空闲的线程。
  interruptIdleWorkers();
  // 钩子函数，在ThreadPoolExecutor中没有任何动作。
  onShutdown(); // hook for ScheduledThreadPoolExecutor
} finally {
  // 释放锁
  mainLock.unlock();
}
// 尝试终止线程池
tryTerminate();
}
</code></pre>
<p><strong>说明</strong>：shutdown()的作用是关闭线程池。</p>
<p>shutdownNow()源码如下：</p>
<pre><code class="java">public List&lt;Runnable&gt; shutdownNow() {
  List&lt;Runnable&gt; tasks;
  final ReentrantLock mainLock = this.mainLock;
  //获取所
  mainLock.lock();
  try {

      checkShutdownAccess();
      //设置线程池状态为stop状态
      advanceRunState(STOP);
      //中断所有线程
      interruptWorkers();
      //取出队列上还未被执行的任务
      tasks = drainQueue();
  } finally {
      mainLock.unlock();
  }
  tryTerminate();
  //返回队列上的任务
  return tasks;
}
</code></pre>
</blockquote>

      
    </div>

    
      

  <div class="popular-posts-header">相关文章</div>
  <ul class="popular-posts">
  
    <li class="popular-posts-item">
      
      
      <div class="popular-posts-title"><a href="/posts/a1d13062/" rel="bookmark">java多线程系列-JUC线程池之03 ThreadPoolExecutor 线程池的创建</a></div>
      
    </li>
  
    <li class="popular-posts-item">
      
      
      <div class="popular-posts-title"><a href="/posts/984191f2/" rel="bookmark">java多线程系列-JUC线程池之 01 线程池架构</a></div>
      
    </li>
  
    <li class="popular-posts-item">
      
      
      <div class="popular-posts-title"><a href="/posts/d4c4bc29/" rel="bookmark">java多线程系列-JUC线程池之04 Future 和Callable</a></div>
      
    </li>
  
    <li class="popular-posts-item">
      
      
      <div class="popular-posts-title"><a href="/posts/931a340/" rel="bookmark">Java CompletableFuture 详解</a></div>
      
    </li>
  
    <li class="popular-posts-item">
      
      
      <div class="popular-posts-title"><a href="/posts/6d00129c/" rel="bookmark">自旋锁</a></div>
      
    </li>
  
  </ul>


    

    
    
    

      
        <div>
        
<div class="my_post_copyright">
  <script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>
  
  <!-- JS库 sweetalert 可修改路径 -->
  <script src="https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"></script>
  <script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script>
  <p><span>本文标题:</span><a href="/posts/ca60f1d2/">java多线程系列-JUC线程池之02 ThreadPoolExecutor 执行流程分析</a></p>
  <p><span>文章作者:</span><a href="/" title="访问 枫秀天涯 的个人博客">枫秀天涯</a></p>
  <p><span>发布时间:</span>2018年07月23日 - 14:35</p>
  <p><span>最后更新:</span>2019年04月18日 - 21:10</p>
  <p><span>原始链接:</span>
     <a href="/posts/ca60f1d2/" title="java多线程系列-JUC线程池之02 ThreadPoolExecutor 执行流程分析">java多线程系列-JUC线程池之02 ThreadPoolExecutor 执行流程分析</a>
    <span class="copy-path" title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="http://fengxiutianya.top/posts/ca60f1d2/" aria-label="复制成功！"></i></span>
  </p>
  <p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</p>  
</div>
<script> 
    var clipboard = new Clipboard('.fa-clipboard');
    $(".fa-clipboard").click(function(){
      clipboard.on('success', function(){
        swal({   
          title: "",   
          text: '复制成功',
          icon: "success", 
          showConfirmButton: true
          });
    });
    });  
</script>

        </div>
      

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JUC/" rel="tag">  <i class="fa fa-tag"></i> JUC</a>
          
            <a href="/tags/线程池/" rel="tag">  <i class="fa fa-tag"></i> 线程池</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/posts/984191f2/" rel="next" title="java多线程系列-JUC线程池之 01 线程池架构">
                <i class="fa fa-chevron-left"></i> java多线程系列-JUC线程池之 01 线程池架构
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/posts/a1d13062/" rel="prev" title="java多线程系列-JUC线程池之03 ThreadPoolExecutor 线程池的创建">
                java多线程系列-JUC线程池之03 ThreadPoolExecutor 线程池的创建 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="枫秀天涯">
            
              <p class="site-author-name" itemprop="name">枫秀天涯</p>
              <p class="site-description motion-element" itemprop="description">java,spring,分布式,数据库</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">149</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">41</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">69</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="https://github.com/fengxiutianya" title="GitHub &rarr; https://github.com/fengxiutianya" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i></a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="mailto:398757724@qq.com" title="E-Mail &rarr; mailto:398757724@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i></a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#java多线程系列-JUC线程池之02-ThreadPoolExecutor-执行流程分析"><span class="nav-text">java多线程系列-JUC线程池之02 ThreadPoolExecutor 执行流程分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概要"><span class="nav-text">概要</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-线程池使用例子"><span class="nav-text">1. 线程池使用例子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-线程池状态"><span class="nav-text">2. 线程池状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-线程池执行任务分析"><span class="nav-text">3. 线程池执行任务分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#任务执行：execute"><span class="nav-text">任务执行：execute</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#addWorker"><span class="nav-text">addWorker</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#addWorkerFailed"><span class="nav-text">addWorkerFailed:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关闭“线程池”"><span class="nav-text">关闭“线程池”</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 – <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">枫秀天涯</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      
      网站总字数
    </span>
    
    <span title="站点总字数">1.3m</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      
      总阅读时长
    </span>
    
    <span title="站点阅读时长">19:18</span>
  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>







  








  
    
    
  
  <script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script>











  



  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script src="/lib/reading_progress/reading_progress.js"></script>


  


  <script src="/js/src/utils.js?v=6.7.0"></script>

  <script src="/js/src/motion.js?v=6.7.0"></script>



  
  


  <script src="/js/src/affix.js?v=6.7.0"></script>

  <script src="/js/src/schemes/pisces.js?v=6.7.0"></script>



  
  <script src="/js/src/scrollspy.js?v=6.7.0"></script>
<script src="/js/src/post-details.js?v=6.7.0"></script>



  


  <script src="/js/src/bootstrap.js?v=6.7.0"></script>



  

  
    <script id="dsq-count-scr" src="https://fengxiutianya.disqus.com/count.js" async></script>
  

  
    <script>
      var disqus_config = function () {
        this.page.url = "http://fengxiutianya.top/posts/ca60f1d2/";
        this.page.identifier = "posts/ca60f1d2/";
        this.page.title = 'java多线程系列-JUC线程池之02 ThreadPoolExecutor 执行流程分析';
        };
      function loadComments () {
        var d = document, s = d.createElement('script');
        s.src = 'https://fengxiutianya.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      }
      
        $(function () {
          var offsetTop = $('#comments').offset().top - $(window).height();
          if (offsetTop <= 0) {
            // load directly when there's no a scrollbar
            loadComments();
          } else {
            $(window).on('scroll.disqus_scroll', function () {
              // offsetTop may changes because of manually resizing browser window or lazy loading images.
              var offsetTop = $('#comments').offset().top - $(window).height();
              var scrollTop = $(window).scrollTop();

              // pre-load comments a bit? (margin or anything else)
              if (offsetTop - scrollTop < 60) {
                $(window).off('.disqus_scroll');
                loadComments();
              }
            });
          }
        });
      
    </script>
  













  




  
  
  
  <link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">

  
  
  <script src="/lib/algolia-instant-search/instantsearch.min.js"></script>
  

  <script src="/js/src/algolia-search.js?v=6.7.0"></script>



  

  
  <script>
    
    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();

      Counter('get', '/classes/Counter', { where: JSON.stringify({ url }) })
        .done(function ({ results }) {
          if (results.length > 0) {
            var counter = results[0];
            
            Counter('put', `/classes/Counter/${counter.objectId}`, JSON.stringify({ time: { "__op":"Increment", "amount":1 } }))
            
            .done(function () {
                  var $element = $(document.getElementById(url));
                  $element.find('.leancloud-visitors-count').text(counter.time + 1);
            })
            
            .fail(function ({ responseJSON }) {
                console.log('Failed to save Visitor num, with error message: ' + responseJSON.error);
            })
          } else {
            
              Counter('post', '/classes/Counter', JSON.stringify({ title: title, url: url, time: 1}))
                .done(function () {
                  var $element = $(document.getElementById(url));
                  $element.find('.leancloud-visitors-count').text(1);
                })
                .fail(function () {
                  console.log('Failed to create');
                });
            
          }
        })
      .fail(function ({ responseJSON }) {
        console.log('LeanCloud Counter Error:' + responseJSON.code + " " + responseJSON.error);
      });
    }
    

    $(function() {
      $.get('https://app-router.leancloud.cn/2/route?appId=' + "8rM8gj5HTRTSqBQdFyePed86-gzGzoHsz")
        .done(function ({ api_server }) {
          var Counter = function (method, url, data) {
            return $.ajax({
              method: method,
              url: `https://${api_server}/1.1${url}`,
              headers: {
                'X-LC-Id': "8rM8gj5HTRTSqBQdFyePed86-gzGzoHsz",
                'X-LC-Key': "f92qb0ijeNp2joqk3ld6IlRW",
                'Content-Type': 'application/json',
              },
              data: data,
            });
          };
          
          addCount(Counter);
          
        })
    });
  </script>



  

  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>


  

  
  

  
  

  


  

  

  

  

  

  

  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      background-color: #eee;
      background-image: linear-gradient(#fcfcfc, #eee);
      border: 1px solid #d5d5d5;
      border-radius: 3px;
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      right: 4px;
      top: 8px;
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1
    }

    .highlight-wrap {
      position: relative;
    }
  </style>
  <script>
    $('.highlight').each(function (i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap');
      $(e).after($wrap);
      $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function (e) {
        var code = $(this).parent().find('.code').find('.line').map(function (i, e) {
          return $(e).text();
        }).toArray().join('\n');
        var ta = document.createElement('textarea');
        var range = document.createRange(); //For Chrome
        var sel = window.getSelection(); //For Chrome
        var yPosition = window.pageYOffset || document.documentElement.scrollTop;
        ta.style.top = yPosition + 'px'; //Prevent page scroll
        ta.style.position = 'absolute';
        ta.style.opacity = '0';
        ta.value = code;
        ta.textContent = code; //For FireFox
        ta.contentEditable = true;
        ta.readOnly = false;
        document.body.appendChild(ta);
        range.selectNode(ta);
        sel.removeAllRanges();
        sel.addRange(range);
        ta.setSelectionRange(0, code.length);
        var result = document.execCommand('copy');
        
          if (result) $(this).text('复制成功');
          else $(this).text('复制失败');
        
        ta.blur(); //For iOS
        $(this).blur();
      })).on('mouseleave', function (e) {
        var $b = $(this).find('.copy-btn');
        setTimeout(function () {
          $b.text('复制');
        }, 300);
      }).append(e);
    })
  </script>


  

  
  
  

  <link rel="stylesheet" href="/lib/prettify/themes/atelier-estuary-light.min.css" type="text/css">

<script src="/lib/prettify/prettify.js"></script>
<script type="text/javascript">
$(window).load(function(){
  // 设置prettify
  $('pre').addClass('prettyprint linenums');
   prettyPrint();
 })
</script>
<style>
pre {
  white-space:pre;
  white-space:pre-wrap;
  word-break:break-all;
  word-wrap:break-word;
}
</style>




</body>
</html>
