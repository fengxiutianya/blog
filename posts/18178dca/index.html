<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
    
      
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/themes/blue/pace-theme-minimal.css">























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=6.7.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.7.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.7.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.7.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.7.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.7.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: 'AQT4XGM95O',
      apiKey: 'd55e0adb332e8d9ef9023a6b4afd46f1',
      indexName: 'my',
      hits: {"per_page":10},
      labels: {"input_placeholder":"请输入搜索内容","hits_empty":"没有发现和 ${query} 有关的内容","hits_stats":"在 ${time} ms 内发现 ${hits} "}
    }
  };
</script>


  




  <meta name="description" content="ReentrantReadWriteLock 简介在前面我们已经分析过JUC中的独占锁：ReentrantLock。本篇文章将对JUC的读写锁ReentrantReadWriteLock进行介绍。 类如如下：  从上图可以看出ReentrantReadWriteLock实现了ReadWriteLock接口，而这个接口从名字就可以看出是读写锁。它维护了一对相关连的锁：读锁和写锁。作用如下  读锁：用">
<meta name="keywords" content="ReentrantReadWriteLock">
<meta property="og:type" content="article">
<meta property="og:title" content="java线程系列 JUC锁 07 ReentrantReadWriteLock">
<meta property="og:url" content="http://fengxiutianya.top/posts/18178dca/index.html">
<meta property="og:site_name" content="枫秀天涯">
<meta property="og:description" content="ReentrantReadWriteLock 简介在前面我们已经分析过JUC中的独占锁：ReentrantLock。本篇文章将对JUC的读写锁ReentrantReadWriteLock进行介绍。 类如如下：  从上图可以看出ReentrantReadWriteLock实现了ReadWriteLock接口，而这个接口从名字就可以看出是读写锁。它维护了一对相关连的锁：读锁和写锁。作用如下  读锁：用">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://fengxiutianya.top/images/pasted-300.png">
<meta property="og:updated_time" content="2019-04-18T13:10:27.792Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java线程系列 JUC锁 07 ReentrantReadWriteLock">
<meta name="twitter:description" content="ReentrantReadWriteLock 简介在前面我们已经分析过JUC中的独占锁：ReentrantLock。本篇文章将对JUC的读写锁ReentrantReadWriteLock进行介绍。 类如如下：  从上图可以看出ReentrantReadWriteLock实现了ReadWriteLock接口，而这个接口从名字就可以看出是读写锁。它维护了一对相关连的锁：读锁和写锁。作用如下  读锁：用">
<meta name="twitter:image" content="http://fengxiutianya.top/images/pasted-300.png">






  <link rel="canonical" href="http://fengxiutianya.top/posts/18178dca/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>java线程系列 JUC锁 07 ReentrantReadWriteLock | 枫秀天涯</title>
  




  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-136781627-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'UA-136781627-1');
  </script>









  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">枫秀天涯</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  
    <div class="reading-progress-bar"></div>
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fengxiutianya.top/posts/18178dca/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="枫秀天涯">
      <meta itemprop="description" content="java,spring,分布式,数据库">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="枫秀天涯">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">java线程系列 JUC锁 07 ReentrantReadWriteLock

              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-03-19 03:46:00" itemprop="dateCreated datePublished" datetime="2019-03-19T03:46:00+08:00">2019-03-19</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-18 21:10:27" itemprop="dateModified" datetime="2019-04-18T21:10:27+08:00">2019-04-18</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/juc/" itemprop="url" rel="index"><span itemprop="name">juc</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/juc/lock/" itemprop="url" rel="index"><span itemprop="name">lock</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/posts/18178dca/#comments" itemprop="discussionUrl">
                
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="posts/18178dca/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/posts/18178dca/" class="leancloud_visitors" data-flag-title="java线程系列 JUC锁 07 ReentrantReadWriteLock">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">17k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">16 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="ReentrantReadWriteLock-简介"><a href="#ReentrantReadWriteLock-简介" class="headerlink" title="ReentrantReadWriteLock 简介"></a>ReentrantReadWriteLock 简介</h2><p>在前面我们已经分析过JUC中的独占锁：ReentrantLock。本篇文章将对JUC的读写锁ReentrantReadWriteLock进行介绍。</p>
<p>类如如下：</p>
<p><img src="/images/pasted-300.png" alt="upload successful"></p>
<p>从上图可以看出ReentrantReadWriteLock实现了ReadWriteLock接口，而这个接口从名字就可以看出是读写锁。它维护了一对相关连的锁：读锁和写锁。作用如下</p>
<ul>
<li>读锁：用于只读操作，不会修改共享数据。是共享锁，能够同时被多个线程锁获取。</li>
<li>写锁：用于写入操作，是独占锁，只能被一个线程锁获取。</li>
</ul>
<p>而这个接口提供了俩个抽象函数，获取读锁的readLock()函数和获取写锁的writeLock()函数。</p>
<p>ReentrantReadWriteLock中包含：Sync对象，读锁ReadLock和写锁WriteLock。</p>
<p>读锁ReadLock和写锁WriteLock都实现了Lock接口。读锁ReadLock和写锁WriteLock中也都分别包含了相同的Sync对象，里面所有的功能实现也都是靠这个对象。它们的Sync对象和ReentrantReadWriteLock的Sync对象是一样，就是通过sync，读锁和写锁实现了对同一个对象的访问。</p>
<p>和ReentrantLock一样，Sync也是一个继承于AQS的抽象类。Sync也包括公平锁FairSync和非公平锁NonfairSync。在创建读写锁时可以选择其中俩个其中一个，默认是NonfairSync。<br><a id="more"></a></p>
<h3 id="公平读写锁源码分析"><a href="#公平读写锁源码分析" class="headerlink" title="公平读写锁源码分析"></a>公平读写锁源码分析</h3><p>这里我们先对公平锁方式实现的读写锁进行源码分析，首先把后面要用到的属性在这里写出来，方便后买源码的理解：</p>
<pre><code class="java">// 内部使用的读锁
private final ReentrantReadWriteLock.ReadLock readerLock;
// 内部使用的写锁
private final ReentrantReadWriteLock.WriteLock writerLock;
// 读锁和写锁共同使用的锁类型，可以是公平锁和非公平锁
final Sync sync;

</code></pre>
<p>这里先看看构造函数和如何获取读锁和写锁</p>
<pre><code class="java">public ReentrantReadWriteLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
    readerLock = new ReadLock(this);
    writerLock = new WriteLock(this);
}

public ReentrantReadWriteLock.WriteLock writeLock() { return writerLock; }
public ReentrantReadWriteLock.ReadLock  readLock()  { return readerLock; }
</code></pre>
<p>从上面可以看出，在创建ReentrantReadWriteLock对象时就会根据是否选择公平锁来创建一个sync锁对象。然后分别创建响应的读锁和写锁。后面获取和使用的读写锁都是在构造函数中创建出来的。</p>
<p>下面开始首先对读锁的获取和释放进行分析。</p>
<h3 id="读锁的获取（公平锁篇）"><a href="#读锁的获取（公平锁篇）" class="headerlink" title="读锁的获取（公平锁篇）"></a>读锁的获取（公平锁篇）</h3><p>读锁也就是共享锁，获取锁的源码如下：</p>
<pre><code class="java">// ReadLock 类中
public void lock() {
    // 获取共享锁
    sync.acquireShared(1);
}

//AQS 类中
public final void acquireShared(int arg) {
    if (tryAcquireShared(arg) &lt; 0)
        doAcquireShared(arg);
}
</code></pre>
<p>从上面可以看出，这里调用的是AQS类中的acquireShared来获取锁。参数和ReentrantLock一样，表示获取锁的数量，1表示当前获取一把共享锁。锁的状态也会加1.</p>
<p>acquireShared()首先会通过tryAcquireShared()来尝试获取锁。尝试成功的话，直接返回。尝试失败的话，则通过doAcquireShared()来获取锁。doAcquireShared()会获取到锁才返回。</p>
<h4 id="tryAcquireShared"><a href="#tryAcquireShared" class="headerlink" title="tryAcquireShared"></a>tryAcquireShared</h4><p>尝试获取共享锁，此函数定义在Sync类中，源码如下</p>
<pre><code class="java">protected final int tryAcquireShared(int unused) {

    Thread current = Thread.currentThread();
    // 获取锁的状态
    int c = getState();
    // 如果锁被独占锁获取并且获取独占锁的线程不是当前线程，
    // 直接返回-1 达标获取锁失败
    if (exclusiveCount(c) != 0 &amp;&amp;
        getExclusiveOwnerThread() != current)
        return -1;
    // 获取读锁的共享计数
    int r = sharedCount(c);
    // 判断不需要阻塞，并且已经获取读锁的数量小于MAX_COUNT
    // 则通过CAS函数更新读锁的状态，将读锁的共享计数加1
    if (!readerShouldBlock() &amp;&amp;
        r &lt; MAX_COUNT &amp;&amp;
        compareAndSetState(c, c + SHARED_UNIT)) {
        // 第一次获取读锁
        if (r == 0) {
            firstReader = current;
            firstReaderHoldCount = 1;

        } else if (firstReader == current) {
              // 如果当前获取锁的线程是第一个获取读锁的线程
            firstReaderHoldCount++;
        } else {
            // HoldCounter是用来统计该线程获取“读取锁”的次数。
            HoldCounter rh = cachedHoldCounter;
            if (rh == null || rh.tid != getThreadId(current))
                cachedHoldCounter = rh = readHolds.get();
            else if (rh.count == 0)
                readHolds.set(rh);
             // 将该线程获取“读取锁”的次数+1。
            rh.count++;
        }
        return 1;
    }
    // 如果获取读锁失败，则通过下面函数来进行获取读锁
    return fullTryAcquireShared(current);
}
</code></pre>
<p>上面流程比较清晰，但是有很多地点你可能看不明白，先跳过，看完后面所有的分析，你就会明白。先总结上面的流程。</p>
<ol>
<li>判断当前锁是否是独占锁，如果是并且独占锁的线程和当前获取锁的线程不相同，则直接返回-1，获取读锁失败。</li>
<li>如果当前线程不应该被阻塞，并且已获取读锁的数量小于最大值，则尝试使用CAS更改读锁的状态值。如果操作成功，进行下一步，操作失败进入最后一步。</li>
<li>这一步主要设置每一个线程获取读锁的数量，主要分为三类来讨论：<ol>
<li>如果是第一个线程来获取读锁，则设置firstReader为当前线程和当前线程拥有的读锁数量为1.</li>
<li>如果不是，则判断当前线程和firstReader线程是否一样，如果一样，则当前线程获取读锁的数量加1</li>
<li>以上都不是，则通过HoldCounter来对当前线程获取读锁的数量加1，而HoldCounter是一个ThreadLocal对象。保证每个线程都有一个不一样的HoldCounter变量。下面会详细解释</li>
</ol>
</li>
<li>如果上面没有成功获取到读锁，但也没有返回。则通过fullTryAcquireShared来获取锁</li>
</ol>
<p>下面对上面每一步使用到的函数进行详细的解释。</p>
<h4 id="计算读锁和写锁已被获取的数量"><a href="#计算读锁和写锁已被获取的数量" class="headerlink" title="计算读锁和写锁已被获取的数量"></a>计算读锁和写锁已被获取的数量</h4><pre><code class="java">static final int SHARED_SHIFT   = 16;
static final int SHARED_UNIT    = (1 &lt;&lt; SHARED_SHIFT);
static final int MAX_COUNT      = (1 &lt;&lt; SHARED_SHIFT) - 1;
static final int EXCLUSIVE_MASK = (1 &lt;&lt; SHARED_SHIFT) - 1;

// 返回共享锁的数量
static int sharedCount(int c)    { return c &gt;&gt;&gt; SHARED_SHIFT; }
// 返回独占说的数量
static int exclusiveCount(int c) { return c &amp; EXCLUSIVE_MASK; }
</code></pre>
<p>从上面可以看出，读锁使用state的高16位来表示数量，而写锁则使用低16位来表示数量。然后通过后面的俩个函数来分别计算对应的数量。</p>
<h4 id="readerShouldBlock"><a href="#readerShouldBlock" class="headerlink" title="readerShouldBlock"></a>readerShouldBlock</h4><p>判断当前获取读锁的线程是否应该阻塞，源码在FairSync中，源码如下</p>
<pre><code class="java">final boolean readerShouldBlock() {
    return hasQueuedPredecessors();
}
</code></pre>
<p>代码比较简单，就是判断当前线程是否是队列中的第一个节点，如果是，则不需要阻塞，不是则需要阻塞。具体的和前面ReentrantLock中的一样，这里具体分析。</p>
<h4 id="HoldCounter"><a href="#HoldCounter" class="headerlink" title="HoldCounter"></a>HoldCounter</h4><p>计算每个线程获取读锁的数量，这里HoldCounter是ThreaLocal类型的变量，如果不了解这个对象，可以看这篇文章<a href="http://fengxiutianya.top/posts/400f00a6/">深入分析ThreadLocal</a>，在分析这个之前，首先看一些定义在Sync类中的属性：</p>
<pre><code class="java">// 计数器对象，用于记录每个线程保持读锁的数量
// 这个对象被记录在ThreadLocal中，缓存在cachedHoldCounter
static final class HoldCounter {
    int count = 0;
    final long tid = getThreadId(Thread.currentThread());
}

// 自定的ThreadLocal对象，设置初始化方法
static final class ThreadLocalHoldCounter
                extends ThreadLocal&lt;HoldCounter&gt; {

    public HoldCounter initialValue() {
        return new HoldCounter();
    }
}
// 记录当前线程获取读锁的数量，在构造器中初始化，当保持的读锁数量为空的时候删除
private transient ThreadLocalHoldCounter readHolds;

// 用于记录上一个线程成功获取读锁的数量
private transient HoldCounter cachedHoldCounter;
// 下面来个一个是记录第一个获取读锁的线程和获取读锁的数量
private transient Thread firstReader = null;
private transient int firstReaderHoldCount;
</code></pre>
<p>下面可以解释tryAcquireShared中的如下代码段</p>
<pre><code class="java">// 第一次获取读锁
if (r == 0) {
    firstReader = current;
    firstReaderHoldCount = 1;

} else if (firstReader == current) {
    // 如果当前获取锁的线程是第一个获取读锁的线程
    firstReaderHoldCount++;
} else {
    // HoldCounter是用来统计该线程获取“读取锁”的次数。
    HoldCounter rh = cachedHoldCounter;
    if (rh == null || rh.tid != getThreadId(current))
        cachedHoldCounter = rh = readHolds.get();
    else if (rh.count == 0)
        readHolds.set(rh);
    // 将该线程获取“读取锁”的次数+1。
    rh.count++;
}
</code></pre>
<ol>
<li>首先判断是否是第一个线程获取读锁，如果是，则设置firstReader和firstReaderHoldCount值吗，可以加快后续此线程的获取读锁和记录读锁的数量。</li>
<li>判断线程是否是firstReader，如果是直接使用firstReaderHoldCount进行累加，可以加快获取的速度。</li>
<li>前面俩个都不是，则获取cachedHoldCounter，判断这个变量中保存的线程id是否和当前线程对应的id相同，如果是，则判断当前读锁的数量是否为0，如果为0，则调用<code>readHolds.set(rh)</code>初始化这个对象然后在原有的读锁数量上加1。</li>
<li>不是则通过readHold获取当前线程对应的HoldCounter，并缓存在cachedHoldCounter中，加速下一次的操作，接着读锁数量加1。</li>
</ol>
<h4 id="fullTryAcquireShared"><a href="#fullTryAcquireShared" class="headerlink" title="fullTryAcquireShared"></a>fullTryAcquireShared</h4><p>这个是tryAcquireShared的最后一步，也就是前面没有获取到共享锁，才会走到这一步，源码如下</p>
<pre><code class="java">final int fullTryAcquireShared(Thread current) {
    // 下面这部分代码和tryAcquireShared有一部分是重复的。
    // 但是tryAcquireShared只是先尝试获取，但是如果出现竞争则获取
    // 不到共享锁，即前面那部分加快锁的获取。下面这部分通过
    // 循环尝试，保证如果可以获取读锁，则一定获取到
    HoldCounter rh = null;
    for (;;) {
        // 获取锁的状态
        int c = getState();
        // 如果是独占锁，并且获取锁的线程不是current线程；则返回-1。
        if (exclusiveCount(c) != 0) {
            if (getExclusiveOwnerThread() != current)
                return -1;

         // 如果需要阻塞等待。
        // 当需要阻塞等待的线程是第1个获取锁的线程的话，则继续往下执行。
        // 当需要阻塞等待的线程获取锁的次数为0时，则返回-1。
        } else if (readerShouldBlock()) {
           // 确保不是有一次获取读锁
            if (firstReader == current) {
                //忽略
            } else {
                // 获取当前线程获取读锁的数量，如果为0，则调用
                // ThreadLocal.remove删除这个ThreadLocal
                if (rh == null) {
                    rh = cachedHoldCounter;
                    if (rh == null || rh.tid != getThreadId(current)) {
                        rh = readHolds.get();
                        if (rh.count == 0)
                            readHolds.remove();
                    }
                }
                // 如果当前线程获取读锁的计数=0,则返回-1。
                // 表示还没有获取过读锁，不在这里进行获取，
                // 则需要阻塞获取读锁的进程
                if (rh.count == 0)
                    return -1;
            }
        }
        // 则获取读取锁的共享统计数；
        // 如果共享统计数超过MAX_COUNT，则抛出异常。
        if (sharedCount(c) == MAX_COUNT)
            throw new Error(&quot;Maximum lock count exceeded&quot;);
        // 将线程的读取锁次数加1
        // 这一步和上面一样，就不具体解释
        // 放在这里主要是因为CAS失败，如果失败，进入下一次循环
        if (compareAndSetState(c, c + SHARED_UNIT)) {       
            if (sharedCount(c) == 0) {
                firstReader = current;
                firstReaderHoldCount = 1;
            } else if (firstReader == current) {
                firstReaderHoldCount++;
            } else {
                if (rh == null)
                    rh = cachedHoldCounter;
                if (rh == null || rh.tid != getThreadId(current))
                    rh = readHolds.get();
                else if (rh.count == 0)
                    readHolds.set(rh);
                rh.count++;
                cachedHoldCounter = rh; // cache for release
            }
            return 1;
        }
    }
}

</code></pre>
<p>fullTryAcquireShared()会根据是否需要阻塞等待，读取锁的共享计数是否超过限制进行处理。如果不需要阻塞等待，并且锁的共享计数没有超过限制，则通过CAS尝试获取锁，并返回1。</p>
<p>至此tryAcquireShared已经解析完成，这里做一个总结：tryAcquireShared将代码分成俩个大部分，首先通过尝试获取锁，如果获取成功直接返回。这是为了加快获取锁。如果没有获取成功，说明CAS失败，则进入fullTryAcquireShared函数进行获取，这里会循环知道CAS交换成功。当然我只是说了一个精简的过程。具体的可以看上面。其他异常情况我也没有总结。</p>
<h4 id="doAcquireShared"><a href="#doAcquireShared" class="headerlink" title="doAcquireShared"></a><strong>doAcquireShared</strong></h4><p>源码如下：</p>
<pre><code class="java">private void doAcquireShared(int arg) {
    // 创建当前线程对应的节点，并将该线程添加到CLH队列中。
    final Node node = addWaiter(Node.SHARED);
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) {
            // 获取前继节点
            final Node p = node.predecessor();
            // 如果当前节点是头结点，尝试获取锁
            if (p == head) {
                int r = tryAcquireShared(arg);
                // 获取成功设置节点为可传播状态，
                // 然后释放后继获取读锁的节点
                if (r &gt;= 0) {
                    setHeadAndPropagate(node, r);
                    p.next = null; // help GC
                    if (interrupted)
                        selfInterrupt();
                    failed = false;
                    return;
                }
            }
            // 如果当前线程不是CLH队列的表头，
            // 则通过shouldParkAfterFailedAcquire()判断是否需要等待，
            // 需要的话，则通过parkAndCheckInterrupt()进行阻塞等待。
            // 若阻塞等待过程中，线程被中断过，则设置interrupted为true。
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        // 上面出现异常，则取消当前节点
        if (failed)
            cancelAcquire(node);
    }
}
</code></pre>
<p>doAcquireShared()的作用是获取共享锁，流程如下</p>
<ol>
<li>创建线程对应的CLH队列的节点，然后将该节点添加到CLH队列中。CLH队列是管理获取锁的等待线程的队列。</li>
<li>获取前继节点，判断当前节点是否是表头，如果当前线程是CLH队列的表头，则尝试获取共享锁；如果获取成功，则释放后继等待获取获取共享锁的线程。然后判断是否中断过，如果产生过中断，则调动中断函数产生一次中断。</li>
<li>上一步没有成功获取锁，需要通过shouldParkAfterFailedAcquire()判断是否阻塞等待，需要阻塞，则通过parkAndCheckInterrupt()进行阻塞等待。</li>
</ol>
<p>doAcquireShared()会通过for循环，不断的进行上面的操作；目的就是获取共享锁。需要注意的是：doAcquireShared()在每一次尝试获取锁时，是通过tryAcquireShared()来执行的！</p>
<p>其实和前面获取独占锁的流程差不多，只不过这里会有一个释放后继获取共享锁的节点。这一步放到下面讲解共享锁的释放中来说。</p>
<h3 id="读锁的释放-公平锁"><a href="#读锁的释放-公平锁" class="headerlink" title="读锁的释放(公平锁)"></a>读锁的释放(公平锁)</h3><p>释放锁是调用下面的函数，源码如下：</p>
<pre><code class="java">public void unlock() {
    sync.releaseShared(1);
}
public final boolean releaseShared(int arg) {
    if (tryReleaseShared(arg)) {
        doReleaseShared();
        return true;
    }
    return false;
}
</code></pre>
<p>上面的过程比较简单，先通过tryReleaseShared释放共享锁，尝试失败则直接返回；如果释放成功，则通过doReleaseShared()去释放共享锁并唤醒后继节点。</p>
<h4 id="tryReleaseShared"><a href="#tryReleaseShared" class="headerlink" title="tryReleaseShared"></a>tryReleaseShared</h4><p>tryReleaseShared()定义在ReentrantReadWriteLock中，源码如下：</p>
<pre><code class="java">protected final boolean tryReleaseShared(int unused) {

    // 获取当前线程，即释放共享锁的线程。
    Thread current = Thread.currentThread();

    // 如果想要释放锁的线程(current)是第1个获取锁(firstReader)的线程，
    // 并且第1个获取锁的线程获取锁的次数=1，则设置firstReader为null；
    // 否则，将第1个获取锁的线程的获取次数-1。
    if (firstReader == current) {
        if (firstReaderHoldCount == 1)
            firstReader = null;
        else
            firstReaderHoldCount--;
    // 获取rh对象，并更新当前线程获取锁的信息。
    } else {
        HoldCounter rh = cachedHoldCounter;
        if (rh == null || rh.tid != current.getId())
            rh = readHolds.get();
        int count = rh.count;
        if (count &lt;= 1) {
            readHolds.remove();
            if (count &lt;= 0)
                throw unmatchedUnlockException();
        }
        --rh.count;
    }
    for (;;) {
        // 获取锁的状态
        int c = getState();
        // 将锁的获取次数-1。
        int nextc = c - SHARED_UNIT;
        // 通过CAS更新锁的状态。通过判断锁的状态是否为0来判断锁是否可以释放。
        if (compareAndSetState(c, nextc))
            return nextc == 0;
    }
}
</code></pre>
<p>上面的注释比较清晰，这里就不具体讲流程，下面来看<strong>doReleaseShared</strong></p>
<h4 id="doReleaseShared"><a href="#doReleaseShared" class="headerlink" title="doReleaseShared"></a><strong>doReleaseShared</strong></h4><pre><code class="java">private void doReleaseShared() {
    for (;;) {
        // 获取CLH队列的头节点
        Node h = head;

        // 如果头节点不为null，并且头节点不等于tail节点。
        if (h != null &amp;&amp; h != tail) {
            // 获取头节点对应的线程的状态
            int ws = h.waitStatus;

            // 如果头节点对应的线程是SIGNAL状态，
            // 则意味着头节点的下一个节点所对应的线程需要被unpark唤醒。
            if (ws == Node.SIGNAL) {
                // 设置头节点对应的线程状态为空状态。失败的话，则继续循环。
                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                    continue;
                // 唤醒头节点的下一个节点所对应的线程。
                unparkSuccessor(h);
            }
            // 如果头节点对应的线程的状态值是0，
            // 则设置头结点的状态为PROPAGATE状态，等待有线程来获取锁才会结束循环。
            else if (ws == 0 &amp;&amp;
                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
                continue;                // loop on failed CAS
        }
        // 如果头节点没有改变，则继续循环。否则，退出循环。
        if (h == head)                   // loop if head changed
            break;
    }
}
</code></pre>
<p>doReleaseShared()会释放共享锁：流程如下：</p>
<ol>
<li>判断队列是否为空，如果为空则继续循环。</li>
<li>如果不为空，则判断头结点是否为SIGNAL状态吗，如果是，则设置状态为0，然后唤醒后继获取锁的节点可以是独占或者共享锁。如果唤醒成功，头结点会改变，这一在最后一步就会推出这个循环</li>
<li>如果头结点状态为0，则设置状态为PROPAGATE，然后继续循环。</li>
<li>如果头结点发生改变，则继续循环。</li>
</ol>
<p>主要流程如上，但是为什么要一直循环这是我不明白的地点。</p>
<h3 id="公平共享锁和非公平共享锁"><a href="#公平共享锁和非公平共享锁" class="headerlink" title="公平共享锁和非公平共享锁"></a><strong>公平共享锁和非公平共享锁</strong></h3><p>和互斥锁ReentrantLock一样，ReadLock也分为公平锁和非公平锁。</p>
<p>公平锁和非公平锁的区别，体现在判断是否需要阻塞的函数readerShouldBlock()的不同。<br>公平锁的readerShouldBlock()的源码如下：</p>
<pre><code class="java">final boolean readerShouldBlock() {
    return hasQueuedPredecessors();
}
</code></pre>
<p>在公平共享锁中，如果在当前线程的前面有其他线程在等待获取共享锁，则返回true；否则，返回false。<br>非公平锁的readerShouldBlock()的源码如下：</p>
<pre><code class="java">final boolean readerShouldBlock() {
    return apparentlyFirstQueuedIsExclusive();
}
final boolean apparentlyFirstQueuedIsExclusive() {
    Node h, s;
    return (h = head) != null &amp;&amp;
        (s = h.next)  != null &amp;&amp;
        !s.isShared()         &amp;&amp;
        s.thread != null;
}
</code></pre>
<p>在非公平共享锁中，它会无视当前线程的前面是否有其他线程在等待获取共享锁。只要该非公平共享锁对应的线程不为null，则返回true。也就是当前锁的类型是共享锁，并且还没有释放。</p>
<h3 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h3><p>写锁的获取和ReentrantLock中独占锁的获取是一样的，这里就不在单独说明。</p>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><pre><code class="java">package JUC.locks;

import lombok.Data;
import lombok.Getter;
import lombok.Setter;

import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

/**************************************
 *      Author : zhangke
 *      Date   : 2018/4/18 22:13
 *      Desc   : 读写锁
 ***************************************/
public class ReadWriteLockTest {

    public static void main(String[] args) {
        // 创建账户
        MyCount myCount = new MyCount(&quot;4238920615242830&quot;, 10000);

        // 创建用户，并指定账户
        User user = new User(&quot;Tommy&quot;, myCount);

        // 分别启动3个“读取账户金钱”的线程 和 3个“设置账户金钱”的线程
        for (int i = 0; i &lt; 3; i++) {
            user.getCash();
            user.setCash((i + 1) * 1000);
        }
    }


    static class User {
        private String name;            //用户名

        private MyCount myCount;        //所要操作的账户

        private ReadWriteLock myLock;   //执行操作所需的锁对象


        public User(String name, MyCount myCount) {
            this.name = name;
            this.myCount = myCount;
            this.myLock = new ReentrantReadWriteLock();

        }


        public void getCash() {
            new Thread(() -&gt; {
                try {
                    myLock.readLock().lock();
                    System.out.println(Thread.currentThread().getName() + &quot; getCash start&quot;);
                    myCount.getCash();
                    Thread.sleep(1);
                    System.out.println(Thread.currentThread().getName() + &quot; getCash end&quot;);
                } catch (InterruptedException e) {

                } finally {
                    myLock.readLock().unlock();
                }
            }).start();
        }


        public void setCash(final int cash) {
            new Thread(() -&gt; {
                try {
                    Thread.sleep(100);
                    myLock.writeLock().lock();
                    System.out.println(Thread.currentThread().getName() 
                                       + &quot; setCash start&quot;);
                    myCount.setCash(cash);
                    System.out.println(Thread.currentThread().getName() 
                                       + &quot; setCash end&quot;);
                } catch (InterruptedException e) {

                } finally {
                    myLock.writeLock().unlock();
                }
            }).start();
        }
    }

    static class MyCount {

        @Getter
        @Setter
        private String id; //账户id

        private int cash; //现金


        public MyCount(String id, int cash) {
            this.id = id;
            this.cash = cash;
        }


        public int getCash() {
            System.out.println(Thread.currentThread().getName() + &quot; getCash&quot; +
                               &quot; cash= &quot; + cash);
            return cash;
        }


        public void setCash(int cash) {
            System.out.println(Thread.currentThread().getName() + &quot; setCash&quot; +
                               &quot; cash= &quot; + cash);
            this.cash = cash;
        }
    }
}

</code></pre>
<p>运行结果：</p>
<pre><code>Thread-0 getCash start
Thread-0 getCash cash= 10000
Thread-0 getCash end
Thread-2 getCash start
Thread-2 getCash cash= 10000
Thread-4 getCash start
Thread-4 getCash cash= 10000
Thread-2 getCash end
Thread-4 getCash end
Thread-5 setCash start
Thread-5 setCash cash= 3000
Thread-5 setCash end
Thread-3 setCash start
Thread-3 setCash cash= 2000
Thread-3 setCash end
Thread-1 setCash start
Thread-1 setCash cash= 1000
Thread-1 setCash end
</code></pre><p>从上面可以观察到读锁是可以共享，也就是读锁的打印的语句不一定是start-end连着的。但是写锁一定是。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.cnblogs.com/skywang12345/p/3505809.html" target="_blank" rel="noopener">Java多线程系列–“JUC锁”08之 共享锁和ReentrantReadWriteLock</a></li>
</ol>

      
    </div>

    
      


    

    
    
    

      
        <div>
        
<div class="my_post_copyright">
  <script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>
  
  <!-- JS库 sweetalert 可修改路径 -->
  <script src="https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"></script>
  <script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script>
  <p><span>本文标题:</span><a href="/posts/18178dca/">java线程系列 JUC锁 07 ReentrantReadWriteLock</a></p>
  <p><span>文章作者:</span><a href="/" title="访问 枫秀天涯 的个人博客">枫秀天涯</a></p>
  <p><span>发布时间:</span>2019年03月19日 - 03:46</p>
  <p><span>最后更新:</span>2019年04月18日 - 21:10</p>
  <p><span>原始链接:</span>
     <a href="/posts/18178dca/" title="java线程系列 JUC锁 07 ReentrantReadWriteLock">java线程系列 JUC锁 07 ReentrantReadWriteLock</a>
    <span class="copy-path" title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="http://fengxiutianya.top/posts/18178dca/" aria-label="复制成功！"></i></span>
  </p>
  <p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</p>  
</div>
<script> 
    var clipboard = new Clipboard('.fa-clipboard');
    $(".fa-clipboard").click(function(){
      clipboard.on('success', function(){
        swal({   
          title: "",   
          text: '复制成功',
          icon: "success", 
          showConfirmButton: true
          });
    });
    });  
</script>

        </div>
      

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/ReentrantReadWriteLock/" rel="tag">  <i class="fa fa-tag"></i> ReentrantReadWriteLock</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/posts/ad8369f2/" rel="next" title="java线程系列 JUC锁 06 阻塞原语LockSupport">
                <i class="fa fa-chevron-left"></i> java线程系列 JUC锁 06 阻塞原语LockSupport
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/posts/b071530c/" rel="prev" title="java线程系列 JUC同步器 08 CountDownLatch">
                java线程系列 JUC同步器 08 CountDownLatch <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="枫秀天涯">
            
              <p class="site-author-name" itemprop="name">枫秀天涯</p>
              <p class="site-description motion-element" itemprop="description">java,spring,分布式,数据库</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">149</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">41</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">69</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="https://github.com/fengxiutianya" title="GitHub &rarr; https://github.com/fengxiutianya" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i></a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="mailto:398757724@qq.com" title="E-Mail &rarr; mailto:398757724@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i></a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#ReentrantReadWriteLock-简介"><span class="nav-text">ReentrantReadWriteLock 简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#公平读写锁源码分析"><span class="nav-text">公平读写锁源码分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#读锁的获取（公平锁篇）"><span class="nav-text">读锁的获取（公平锁篇）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#tryAcquireShared"><span class="nav-text">tryAcquireShared</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#计算读锁和写锁已被获取的数量"><span class="nav-text">计算读锁和写锁已被获取的数量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#readerShouldBlock"><span class="nav-text">readerShouldBlock</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HoldCounter"><span class="nav-text">HoldCounter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fullTryAcquireShared"><span class="nav-text">fullTryAcquireShared</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#doAcquireShared"><span class="nav-text">doAcquireShared</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#读锁的释放-公平锁"><span class="nav-text">读锁的释放(公平锁)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#tryReleaseShared"><span class="nav-text">tryReleaseShared</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#doReleaseShared"><span class="nav-text">doReleaseShared</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#公平共享锁和非公平共享锁"><span class="nav-text">公平共享锁和非公平共享锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#写锁"><span class="nav-text">写锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用示例"><span class="nav-text">使用示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考"><span class="nav-text">参考</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 – <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">枫秀天涯</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      
      网站总字数
    </span>
    
    <span title="站点总字数">1.3m</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      
      总阅读时长
    </span>
    
    <span title="站点阅读时长">19:18</span>
  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>







  








  
    
    
  
  <script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script>











  



  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script src="/lib/reading_progress/reading_progress.js"></script>


  


  <script src="/js/src/utils.js?v=6.7.0"></script>

  <script src="/js/src/motion.js?v=6.7.0"></script>



  
  


  <script src="/js/src/affix.js?v=6.7.0"></script>

  <script src="/js/src/schemes/pisces.js?v=6.7.0"></script>



  
  <script src="/js/src/scrollspy.js?v=6.7.0"></script>
<script src="/js/src/post-details.js?v=6.7.0"></script>



  


  <script src="/js/src/bootstrap.js?v=6.7.0"></script>



  

  
    <script id="dsq-count-scr" src="https://fengxiutianya.disqus.com/count.js" async></script>
  

  
    <script>
      var disqus_config = function () {
        this.page.url = "http://fengxiutianya.top/posts/18178dca/";
        this.page.identifier = "posts/18178dca/";
        this.page.title = 'java线程系列 JUC锁 07 ReentrantReadWriteLock';
        };
      function loadComments () {
        var d = document, s = d.createElement('script');
        s.src = 'https://fengxiutianya.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      }
      
        $(function () {
          var offsetTop = $('#comments').offset().top - $(window).height();
          if (offsetTop <= 0) {
            // load directly when there's no a scrollbar
            loadComments();
          } else {
            $(window).on('scroll.disqus_scroll', function () {
              // offsetTop may changes because of manually resizing browser window or lazy loading images.
              var offsetTop = $('#comments').offset().top - $(window).height();
              var scrollTop = $(window).scrollTop();

              // pre-load comments a bit? (margin or anything else)
              if (offsetTop - scrollTop < 60) {
                $(window).off('.disqus_scroll');
                loadComments();
              }
            });
          }
        });
      
    </script>
  













  




  
  
  
  <link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">

  
  
  <script src="/lib/algolia-instant-search/instantsearch.min.js"></script>
  

  <script src="/js/src/algolia-search.js?v=6.7.0"></script>



  

  
  <script>
    
    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();

      Counter('get', '/classes/Counter', { where: JSON.stringify({ url }) })
        .done(function ({ results }) {
          if (results.length > 0) {
            var counter = results[0];
            
            Counter('put', `/classes/Counter/${counter.objectId}`, JSON.stringify({ time: { "__op":"Increment", "amount":1 } }))
            
            .done(function () {
                  var $element = $(document.getElementById(url));
                  $element.find('.leancloud-visitors-count').text(counter.time + 1);
            })
            
            .fail(function ({ responseJSON }) {
                console.log('Failed to save Visitor num, with error message: ' + responseJSON.error);
            })
          } else {
            
              Counter('post', '/classes/Counter', JSON.stringify({ title: title, url: url, time: 1}))
                .done(function () {
                  var $element = $(document.getElementById(url));
                  $element.find('.leancloud-visitors-count').text(1);
                })
                .fail(function () {
                  console.log('Failed to create');
                });
            
          }
        })
      .fail(function ({ responseJSON }) {
        console.log('LeanCloud Counter Error:' + responseJSON.code + " " + responseJSON.error);
      });
    }
    

    $(function() {
      $.get('https://app-router.leancloud.cn/2/route?appId=' + "8rM8gj5HTRTSqBQdFyePed86-gzGzoHsz")
        .done(function ({ api_server }) {
          var Counter = function (method, url, data) {
            return $.ajax({
              method: method,
              url: `https://${api_server}/1.1${url}`,
              headers: {
                'X-LC-Id': "8rM8gj5HTRTSqBQdFyePed86-gzGzoHsz",
                'X-LC-Key': "f92qb0ijeNp2joqk3ld6IlRW",
                'Content-Type': 'application/json',
              },
              data: data,
            });
          };
          
          addCount(Counter);
          
        })
    });
  </script>



  

  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>


  

  
  

  
  

  


  

  

  

  

  

  

  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      background-color: #eee;
      background-image: linear-gradient(#fcfcfc, #eee);
      border: 1px solid #d5d5d5;
      border-radius: 3px;
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      right: 4px;
      top: 8px;
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1
    }

    .highlight-wrap {
      position: relative;
    }
  </style>
  <script>
    $('.highlight').each(function (i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap');
      $(e).after($wrap);
      $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function (e) {
        var code = $(this).parent().find('.code').find('.line').map(function (i, e) {
          return $(e).text();
        }).toArray().join('\n');
        var ta = document.createElement('textarea');
        var range = document.createRange(); //For Chrome
        var sel = window.getSelection(); //For Chrome
        var yPosition = window.pageYOffset || document.documentElement.scrollTop;
        ta.style.top = yPosition + 'px'; //Prevent page scroll
        ta.style.position = 'absolute';
        ta.style.opacity = '0';
        ta.value = code;
        ta.textContent = code; //For FireFox
        ta.contentEditable = true;
        ta.readOnly = false;
        document.body.appendChild(ta);
        range.selectNode(ta);
        sel.removeAllRanges();
        sel.addRange(range);
        ta.setSelectionRange(0, code.length);
        var result = document.execCommand('copy');
        
          if (result) $(this).text('复制成功');
          else $(this).text('复制失败');
        
        ta.blur(); //For iOS
        $(this).blur();
      })).on('mouseleave', function (e) {
        var $b = $(this).find('.copy-btn');
        setTimeout(function () {
          $b.text('复制');
        }, 300);
      }).append(e);
    })
  </script>


  

  
  
  

  <link rel="stylesheet" href="/lib/prettify/themes/atelier-estuary-light.min.css" type="text/css">

<script src="/lib/prettify/prettify.js"></script>
<script type="text/javascript">
$(window).load(function(){
  // 设置prettify
  $('pre').addClass('prettyprint linenums');
   prettyPrint();
 })
</script>
<style>
pre {
  white-space:pre;
  white-space:pre-wrap;
  word-break:break-all;
  word-wrap:break-word;
}
</style>




</body>
</html>
